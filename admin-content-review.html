<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üõ°Ô∏è Admin Content Review & Gaussian Blur Tool</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .image-container {
            position: relative;
            display: inline-block;
            max-width: 100%;
        }
        
        .portrait-rotated {
            transform: rotate(90deg) !important;
            transform-origin: center center !important;
        }
        
        .portrait-container {
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
        }
        
        .blur-overlay {
            position: absolute;
            border: 2px solid #dc3545;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: var(--blur-shape, 0px);
            overflow: hidden;
        }
        
        /* Shape styling for blur overlays */
        .blur-overlay.shape-oval {
            border-radius: 50%;
        }
        
        .blur-overlay.shape-rounded {
            border-radius: 15px;
        }
        
        .blur-overlay.shape-square {
            border-radius: 0px;
        }
        
        .blur-overlay:hover {
            border-color: #ffc107;
            background: rgba(255, 255, 0, 0.2);
        }
        
        .blur-overlay.disabled {
            display: none !important;
        }
        
        .violation-label {
            position: absolute;
            top: -25px;
            left: 0;
            background: #dc3545;
            color: white;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: bold;
        }
        
        .image-preview {
            max-width: 100%;
            max-height: 600px;
            object-fit: contain;
        }
        
        .control-panel {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .violation-item {
            padding: 10px;
            margin: 5px 0;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            background: #fff;
        }
        
        .violation-item.blurred {
            background: #f8d7da;
            border-color: #dc3545;
        }
        
        .violation-item.approved {
            background: #d4edda;
            border-color: #28a745;
        }
        
        /* Drag/Resize Handles */
        .resize-handle {
            position: absolute;
            background: #007bff;
            border: 2px solid #fff;
            border-radius: 50%;
            width: 12px;
            height: 12px;
            z-index: 20;
            cursor: pointer;
        }
        
        .resize-handle.nw { top: -6px; left: -6px; cursor: nw-resize; }
        .resize-handle.ne { top: -6px; right: -6px; cursor: ne-resize; }
        .resize-handle.sw { bottom: -6px; left: -6px; cursor: sw-resize; }
        .resize-handle.se { bottom: -6px; right: -6px; cursor: se-resize; }
        .resize-handle.n { top: -6px; left: 50%; margin-left: -6px; cursor: n-resize; }
        .resize-handle.s { bottom: -6px; left: 50%; margin-left: -6px; cursor: s-resize; }
        .resize-handle.w { top: 50%; left: -6px; margin-top: -6px; cursor: w-resize; }
        .resize-handle.e { top: 50%; right: -6px; margin-top: -6px; cursor: e-resize; }
        
        .blur-overlay:hover .resize-handle {
            background: #ffc107;
        }
        
        .blur-overlay.dragging {
            cursor: move;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-4">
        <div class="row">
            <div class="col-12">
                <h2>üõ°Ô∏è Admin Content Review & Gaussian Blur Tool</h2>
                <div class="alert alert-info">
                    <strong>Instructions:</strong> Upload an image to analyze violations, then click on detected areas to toggle blur on/off. 
                    Adjust blur strength and opacity with the controls below.
                </div>
            </div>
        </div>
        
        <div class="row">
            <!-- Upload & Controls -->
            <div class="col-md-4">
                <div class="control-panel">
                    <h5>üì§ Upload Image for Review</h5>
                    
                    <div class="mb-3">
                        <label class="form-label">Select Model:</label>
                        <select class="form-select" id="modelSelect">
                            <option value="">Loading models...</option>
                        </select>
                    </div>
                    
                    <div class="mb-3">
                        <label class="form-label">Context Type:</label>
                        <select class="form-select" id="contextType">
                            <option value="public_gallery">Public Gallery</option>
                            <option value="private_collection">Private Collection</option>
                            <option value="paysite_content">Paysite Content</option>
                            <option value="store_media">Store Media</option>
                        </select>
                    </div>
                    
                    <div class="mb-3">
                        <input type="file" class="form-control" id="imageUpload" accept="image/*">
                    </div>
                    
                    <button class="btn btn-primary" onclick="analyzeImage()" id="analyzeButton" disabled>
                        üîç Analyze Violations
                    </button>
                </div>
                
                <div id="blurControls" class="control-panel" style="display: none;">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h5>üéõÔ∏è Blur Controls</h5>
                        <div id="previewEyeToggle" onclick="toggleSharpPreview()" style="
                            background: rgba(0,0,0,0.7);
                            color: white;
                            border-radius: 50%;
                            width: 40px;
                            height: 40px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            cursor: pointer;
                            font-size: 18px;
                            user-select: none;
                        " title="Toggle blur preview">
                            ‚óè
                        </div>
                    </div>
                    
                    <div class="mb-3">
                        <label class="form-label">Blur Strength:</label>
                        <input type="range" class="form-range" id="blurStrength" min="1" max="10" value="3" 
                               onchange="updateBlurSettings()" oninput="updateBlurSettings()">
                        <small class="text-muted">Strength: <span id="blurStrengthValue">3</span></small>
                    </div>
                    
                    
                    <div class="mb-3">
                        <label class="form-label">Blur Shape:</label>
                        <select class="form-select" id="blurShape" onchange="updateBlurSettings()">
                            <option value="square">Rectangle</option>
                            <option value="rounded">Rounded Rectangle</option>
                            <option value="oval">Oval</option>
                        </select>
                    </div>
                    
                    
                    <div class="mb-3">
                        <button class="btn btn-info btn-sm w-100" onclick="addManualBlurArea()">
                            ‚ûï Add Blur Area
                        </button>
                    </div>
                    
                    <div class="d-grid gap-2">
                        <button class="btn btn-warning" onclick="toggleAllBlurs()">
                            üîÑ Toggle All Blurs
                        </button>
                        <button class="btn btn-success" onclick="saveModeratedImage()">
                            üíæ Save Moderated Version
                        </button>
                        <button class="btn btn-danger" onclick="rejectImage()">
                            ‚ùå Reject Image
                        </button>
                    </div>
                </div>
                
                <div id="violationsList" class="control-panel" style="display: none;">
                    <h5>üö® Detected Violations</h5>
                    <div id="violationsContent"></div>
                </div>
            </div>
            
            <!-- Image Preview -->
            <div class="col-md-8">
                <div class="card">
                    <div class="card-header">
                        <h5>üñºÔ∏è Image Review</h5>
                        <small class="text-muted">Click on highlighted areas to toggle blur on/off</small>
                    </div>
                    <div class="card-body text-center">
                        <div id="imageContainer">
                            <div class="text-muted py-5">
                                <i class="bi bi-image" style="font-size: 4rem;"></i>
                                <h4>Upload an image to begin review</h4>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div id="analysisResults" class="mt-3" style="display: none;">
                    <div class="card">
                        <div class="card-header">
                            <h6>üìä AI Analysis Results</h6>
                        </div>
                        <div class="card-body">
                            <div id="analysisContent"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentImage = null;
        let analysisData = null;
        let currentUploadedFilePath = null;
        let blurStates = {};
        
        function analyzeImage() {
            const fileInput = document.getElementById('imageUpload');
            const modelSelect = document.getElementById('modelSelect');
            const contextTypeSelect = document.getElementById('contextType');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select an image first');
                return;
            }
            
            if (!modelSelect.value) {
                alert('Please select a model first');
                return;
            }
            
            const selectedModel = JSON.parse(modelSelect.value);
            
            // Create FormData for upload
            const formData = new FormData();
            formData.append('image', file);
            formData.append('context_type', contextTypeSelect.value);
            formData.append('model_id', selectedModel.id);
            formData.append('model_slug', selectedModel.slug);
            
            console.log(`Analyzing image for model: ${selectedModel.name} (ID: ${selectedModel.id})`);
            
            // Show loading
            document.getElementById('imageContainer').innerHTML = `
                <div class="text-center py-5">
                    <div class="spinner-border text-primary" role="status"></div>
                    <h5 class="mt-3">Analyzing image for ${selectedModel.name}...</h5>
                    <p class="text-muted">Context: ${contextTypeSelect.options[contextTypeSelect.selectedIndex].text}</p>
                </div>
            `;
            
            // Upload and analyze
            fetch('/api/enhanced-content-moderation/upload', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Store the uploaded file path for preview generation
                    currentUploadedFilePath = data.data.original_path || data.data.image_path || data.data.file_path || data.data.filePath;
                    console.log('üìÅ Stored uploaded file path:', currentUploadedFilePath);
                    console.log('üìÅ Full response data:', data.data);
                    console.log('üìÅ Available path fields:', {
                        original_path: data.data.original_path,
                        image_path: data.data.image_path, 
                        final_location: data.data.final_location,
                        file_path: data.data.file_path
                    });
                    displayImageWithViolations(file, data.data);
                } else {
                    alert('Analysis failed: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Upload failed: ' + error.message);
            });
        }
        
        function displayImageWithViolations(file, analysis) {
            analysisData = analysis;
            
            console.log('üì∏ Loading image in EXIF-stripped mode to match NudeNet coordinate space...');
            
            // Load image with EXIF orientation disabled to match backend processing  
            loadImage(file, function (canvas) {
                if (canvas.type === "error") {
                    console.error("Failed to load image in EXIF-stripped mode:", canvas);
                    return;
                }
                
                console.log('‚úÖ Using EXIF-stripped coordinate space (matching NudeNet and backend blur processing)');
                
                // Use the raw EXIF-stripped canvas directly - no landscape conversion
                let finalCanvas = canvas;
                
                console.log('üñºÔ∏è Moderation canvas (EXIF-stripped):', finalCanvas.width, 'x', finalCanvas.height);
                
                const container = document.getElementById('imageContainer');
                container.innerHTML = `
                    <div class="image-container">
                    </div>
                `;
                const imageContainer = container.querySelector('.image-container');
                
                finalCanvas.className = 'image-preview';
                finalCanvas.style.maxWidth = '100%';
                finalCanvas.style.height = 'auto';
                finalCanvas.style.display = 'block';
                
                imageContainer.appendChild(finalCanvas);
                
                currentImage = {
                    naturalWidth: finalCanvas.width,
                    naturalHeight: finalCanvas.height,
                    canvas: finalCanvas
                };
                
                // Reset blur controls to default state
                resetBlurControlsToDefault();
                
                processImageWithAnalysis(finalCanvas, analysis);
                
            }, {
                orientation: 1,
                canvas: true
            });
        }
            
        function processImageWithAnalysis(canvas, analysis) {
                const container = document.getElementById('imageContainer');
                
                // Store the canvas as current image for consistent access
                currentImage = {
                    naturalWidth: canvas.width,
                    naturalHeight: canvas.height,
                    canvas: canvas
                };
                
                // Create image container with overlays
                let overlaysHtml = '';
                let violationsHtml = '';
                
                if (analysis.part_locations) {
                    Object.entries(analysis.part_locations).forEach(([part, location]) => {
                        const overlayId = `overlay-${part}`;
                        blurStates[part] = true; // Default to blurred
                        
                        // Debug coordinates with canvas
                        console.log(`=== CANVAS COORDINATES DEBUG for ${part} ===`);
                        console.log('Raw location object:', location);
                        console.log('Location properties:', Object.keys(location));
                        console.log(`x: ${location.x}, y: ${location.y}, width: ${location.width}, height: ${location.height}`);
                        console.log(`Canvas dimensions: ${canvas.width} x ${canvas.height}`);
                        
                        // üîç SIZE DEBUGGING: Log actual pixel areas to verify labeling
                        const actualArea = Math.abs(location.width) * Math.abs(location.height);
                        console.log(`üîç ${part} AREA ANALYSIS:`);
                        console.log(`   Dimensions: ${Math.abs(location.width)} x ${Math.abs(location.height)}`);
                        console.log(`   Total Area: ${actualArea} pixels`);
                        console.log(`   Shape: ${Math.abs(location.width) > Math.abs(location.height) ? 'WIDE/HORIZONTAL' : 'TALL/VERTICAL'}`);
                        
                        // Mark this detection for verification
                        if (part === 'BUTTOCKS_EXPOSED') {
                            console.log(`üçë BUTTOCKS should typically be WIDE/HORIZONTAL - is this correct?`);
                        } else if (part === 'FEMALE_GENITALIA_EXPOSED') {
                            console.log(`üå∏ GENITALIA should typically be smaller area - is this correct?`);
                        }
                        
                        // Transform AI coordinates if we rotated portrait to landscape for moderation
                        let x = location.x;
                        let y = location.y;
                        let width = Math.abs(location.width);
                        let height = Math.abs(location.height);
                        
                        // Handle negative dimensions by adjusting position
                        if (location.width < 0) {
                            x = x - width;
                        }
                        if (location.height < 0) {
                            y = y - height;
                        }
                        
                        // No coordinate transformation needed - both AI and frontend use upright orientation
                        
                        console.log(`=== USING UPRIGHT COORDINATES ===`);
                        console.log(`AI coordinates: x=${x}, y=${y}, w=${width}, h=${height}`);
                        console.log(`Canvas natural size: ${canvas.width} x ${canvas.height}`);
                        
                        overlaysHtml += `
                            <div id="${overlayId}" 
                                 class="blur-overlay shape-square" 
                                 data-original-x="${x}"
                                 data-original-y="${y}"
                                 data-original-width="${width}"
                                 data-original-height="${height}"
                                 data-part="${part}"
                                 style="
                                     left: 0px; 
                                     top: 0px; 
                                     width: 100px; 
                                     height: 100px;
                                     --blur-strength: 10px;
                                     z-index: 10;
                                     border: 3px solid ${part === 'BUTTOCKS_EXPOSED' ? '#FF6B35' : part === 'FEMALE_GENITALIA_EXPOSED' ? '#8E44AD' : '#FF0000'};
                                     box-shadow: 0 0 10px ${part === 'BUTTOCKS_EXPOSED' ? '#FF6B35' : part === 'FEMALE_GENITALIA_EXPOSED' ? '#8E44AD' : '#FF0000'};
                                 ">
                                <div class="violation-label" style="background: ${part === 'BUTTOCKS_EXPOSED' ? '#FF6B35' : part === 'FEMALE_GENITALIA_EXPOSED' ? '#8E44AD' : 'red'}; color: white; font-weight: bold;">
                                    ${part === 'BUTTOCKS_EXPOSED' ? 'BUTTOCKS' : part === 'FEMALE_GENITALIA_EXPOSED' ? 'GENITALIA' : part.toUpperCase()}
                                </div>
                                
                                <!-- Resize Handles -->
                                <div class="resize-handle nw" data-direction="nw"></div>
                                <div class="resize-handle ne" data-direction="ne"></div>
                                <div class="resize-handle sw" data-direction="sw"></div>
                                <div class="resize-handle se" data-direction="se"></div>
                                <div class="resize-handle n" data-direction="n"></div>
                                <div class="resize-handle s" data-direction="s"></div>
                                <div class="resize-handle w" data-direction="w"></div>
                                <div class="resize-handle e" data-direction="e"></div>
                            </div>
                        `;
                        
                        console.log(`Created overlay HTML for ${part} with canvas dimensions: ${width}x${height}`);
                        
                        violationsHtml += `
                            <div id="violation-${part}" class="violation-item blurred" style="border-left: 4px solid ${part === 'BUTTOCKS_EXPOSED' ? '#FF6B35' : part === 'FEMALE_GENITALIA_EXPOSED' ? '#8E44AD' : '#FF0000'};">
                                <div class="d-flex justify-content-between align-items-center">
                                    <div>
                                        <strong style="color: ${part === 'BUTTOCKS_EXPOSED' ? '#FF6B35' : part === 'FEMALE_GENITALIA_EXPOSED' ? '#8E44AD' : '#FF0000'};">${part === 'BUTTOCKS_EXPOSED' ? 'BUTTOCKS' : part === 'FEMALE_GENITALIA_EXPOSED' ? 'GENITALIA' : part.toUpperCase()}</strong>
                                        <br><small>Detected content area</small>
                                    </div>
                                    <button class="btn btn-sm" style="border-color: ${part === 'BUTTOCKS_EXPOSED' ? '#FF6B35' : part === 'FEMALE_GENITALIA_EXPOSED' ? '#8E44AD' : '#FF0000'}; color: ${part === 'BUTTOCKS_EXPOSED' ? '#FF6B35' : part === 'FEMALE_GENITALIA_EXPOSED' ? '#8E44AD' : '#FF0000'};" onclick="toggleBlur('${part}')">
                                        <span id="btn-${part}">üü¶ Blurred</span>
                                    </button>
                                </div>
                            </div>
                        `;
                    });
                }
                
                container.innerHTML = `
                    <div class="image-container">
                        ${overlaysHtml}
                    </div>
                `;
                
                // Add the canvas to the container
                container.querySelector('.image-container').appendChild(canvas);
                canvas.className = 'image-preview';
                canvas.setAttribute('alt', 'Content under review');
                
                // Initialize drag/resize functionality and blur previews
                setTimeout(() => {
                    console.log('Initializing blur overlays...');
                    document.querySelectorAll('.blur-overlay').forEach((overlay, index) => {
                        console.log(`Initializing overlay ${index}:`, overlay);
                        const part = overlay.dataset.part;
                        
                        // Initialize drag and resize functionality
                        initializeDragResize(overlay);
                        
                        // Initialize blur preview with default strength
                        updateCanvasBlurPreview(overlay, 10);
                    });
                    
                    // ‚úÖ Immediately apply blur previews after overlays are placed
                    syncAllBlurPreviews();
                }, 500); // Increased delay to ensure image is fully loaded
                
                // Show controls and violations
                document.getElementById('blurControls').style.display = 'block';
                document.getElementById('violationsList').style.display = 'block';
                document.getElementById('violationsContent').innerHTML = violationsHtml;
                
                // Show analysis results
                displayAnalysisResults(analysis);
                
                // Scale overlays after image is rendered
                setTimeout(() => {
                    scaleOverlays();
                    // Activate initial preview mode (defaulting to true)
                    setTimeout(activateInitialPreview, 200);
                }, 100);
            }
        
        function transformCoordinatesForOrientation(x, y, width, height, imageWidth, imageHeight, orientation) {
            // Transform coordinates from displayed/rotated view to raw image coordinates
            switch (orientation) {
                case 6: // 90¬∞ clockwise rotation
                    return {
                        x: Math.round(y),
                        y: Math.round(imageHeight - x - width),
                        width: Math.round(height),
                        height: Math.round(width)
                    };
                case 8: // 90¬∞ counter-clockwise rotation  
                    return {
                        x: Math.round(imageWidth - y - height),
                        y: Math.round(x),
                        width: Math.round(height),
                        height: Math.round(width)
                    };
                case 3: // 180¬∞ rotation
                    return {
                        x: Math.round(imageWidth - x - width),
                        y: Math.round(imageHeight - y - height),
                        width: Math.round(width),
                        height: Math.round(height)
                    };
                default: // No transformation needed (orientation 1)
                    return { x, y, width, height };
            }
        }
        
        function getImageDisplayInfo() {
            const imageElement = document.querySelector('.image-preview');
            if (!imageElement || !currentImage) return null;
            
            // For now, let's add better debugging to understand the coordinate issue
            console.log(`DEBUG: Image natural dimensions: ${currentImage.naturalWidth}x${currentImage.naturalHeight}`);
            console.log(`DEBUG: Container dimensions: ${imageElement.clientWidth}x${imageElement.clientHeight}`);
            console.log(`DEBUG: Current analysisData:`, analysisData);
            
            // Calculate the actual image display size (accounting for object-fit: contain)
            const naturalAspectRatio = currentImage.naturalWidth / currentImage.naturalHeight;
            const containerAspectRatio = imageElement.clientWidth / imageElement.clientHeight;
            
            let actualDisplayWidth, actualDisplayHeight, offsetX, offsetY;
            
            if (naturalAspectRatio > containerAspectRatio) {
                // Image is wider than container - width is constrained
                actualDisplayWidth = imageElement.clientWidth;
                actualDisplayHeight = actualDisplayWidth / naturalAspectRatio;
                offsetX = 0;
                offsetY = (imageElement.clientHeight - actualDisplayHeight) / 2;
            } else {
                // Image is taller than container - height is constrained
                actualDisplayHeight = imageElement.clientHeight;
                actualDisplayWidth = actualDisplayHeight * naturalAspectRatio;
                offsetX = (imageElement.clientWidth - actualDisplayWidth) / 2;
                offsetY = 0;
            }
            
            return {
                actualDisplayWidth,
                actualDisplayHeight,
                offsetX,
                offsetY,
                scaleX: actualDisplayWidth / currentImage.naturalWidth,
                scaleY: actualDisplayHeight / currentImage.naturalHeight
            };
        }
        
        function scaleOverlays() {
            const displayInfo = getImageDisplayInfo();
            if (!displayInfo) return;
            
            const { actualDisplayWidth, actualDisplayHeight, offsetX, offsetY, scaleX, scaleY } = displayInfo;
            
            console.log(`Image scaling - Natural: ${currentImage.naturalWidth}x${currentImage.naturalHeight}`);
            console.log(`Container: ${document.querySelector('.image-preview').clientWidth}x${document.querySelector('.image-preview').clientHeight}`);
            console.log(`Actual display: ${actualDisplayWidth}x${actualDisplayHeight}`);
            console.log(`Offset: ${offsetX}, ${offsetY}`);
            console.log(`Scale factors: X=${scaleX.toFixed(3)}, Y=${scaleY.toFixed(3)}`);
            
            // Update all blur overlays with scaled coordinates
            document.querySelectorAll('.blur-overlay').forEach(overlay => {
                const originalX = parseInt(overlay.dataset.originalX);
                const originalY = parseInt(overlay.dataset.originalY);
                const originalWidth = parseInt(overlay.dataset.originalWidth);
                const originalHeight = parseInt(overlay.dataset.originalHeight);
                
                // Apply scaling and offset
                const scaledX = Math.round(originalX * scaleX + offsetX);
                const scaledY = Math.round(originalY * scaleY + offsetY);
                const scaledWidth = Math.round(originalWidth * scaleX);
                const scaledHeight = Math.round(originalHeight * scaleY);
                
                console.log(`=== SCALING DEBUG for ${overlay.dataset.part} ===`);
                console.log(`  Original (stored): ${originalX},${originalY} ${originalWidth}x${originalHeight}`);
                console.log(`  Image natural: ${currentImage.naturalWidth}x${currentImage.naturalHeight}`);
                console.log(`  Display area: ${actualDisplayWidth}x${actualDisplayHeight}`);
                console.log(`  Scale factors: ${scaleX.toFixed(3)}, ${scaleY.toFixed(3)}`);
                console.log(`  Offset: ${offsetX}, ${offsetY}`);
                console.log(`  Scaled result: ${scaledX},${scaledY} ${scaledWidth}x${scaledHeight}`);
                
                // Update overlay position and size
                overlay.style.left = `${scaledX}px`;
                overlay.style.top = `${scaledY}px`;
                overlay.style.width = `${scaledWidth}px`;
                overlay.style.height = `${scaledHeight}px`;
                
                // Update blur preview with current blur strength
                const currentBlur = document.getElementById('blurStrength')?.value || 10;
                updateCanvasBlurPreview(overlay, parseInt(currentBlur));
            });
        }
        
        // Drag and Resize functionality
        let dragState = {
            isDragging: false,
            isResizing: false,
            overlay: null,
            startX: 0,
            startY: 0,
            startLeft: 0,
            startTop: 0,
            startWidth: 0,
            startHeight: 0,
            resizeDirection: null
        };
        
        function initializeDragResize(overlay) {
            console.log('Initializing drag/resize for:', overlay.dataset.part);
            
            // Make overlay draggable (on the overlay itself, not handles)
            overlay.addEventListener('mousedown', (e) => {
                // Only start drag if not clicking on a resize handle
                if (!e.target.classList.contains('resize-handle')) {
                    e.preventDefault();
                    startDrag(e, overlay);
                }
            });
            
            // Add resize handle listeners
            const handles = overlay.querySelectorAll('.resize-handle');
            handles.forEach(handle => {
                handle.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation(); // Prevent triggering drag
                    startResize(e, overlay, handle.dataset.direction);
                });
            });
        }
        
        function startDrag(e, overlay) {
            console.log('Starting drag for:', overlay.dataset.part);
            dragState.isDragging = true;
            dragState.overlay = overlay;
            dragState.startX = e.clientX;
            dragState.startY = e.clientY;
            dragState.startLeft = parseInt(overlay.style.left);
            dragState.startTop = parseInt(overlay.style.top);
            
            overlay.classList.add('dragging');
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        }
        
        function startResize(e, overlay, direction) {
            console.log('Starting resize for:', overlay.dataset.part, 'direction:', direction);
            dragState.isResizing = true;
            dragState.overlay = overlay;
            dragState.resizeDirection = direction;
            dragState.startX = e.clientX;
            dragState.startY = e.clientY;
            dragState.startLeft = parseInt(overlay.style.left);
            dragState.startTop = parseInt(overlay.style.top);
            dragState.startWidth = parseInt(overlay.style.width);
            dragState.startHeight = parseInt(overlay.style.height);
            
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        }
        
        function handleMouseMove(e) {
            if (!dragState.isDragging && !dragState.isResizing) return;
            
            e.preventDefault(); // Prevent text selection and other interference
            
            const deltaX = e.clientX - dragState.startX;
            const deltaY = e.clientY - dragState.startY;
            
            // Get display info once for the entire function
            const displayInfo = getImageDisplayInfo();
            
            if (dragState.isDragging) {
                // Update position with smooth movement
                const newLeft = dragState.startLeft + deltaX;
                const newTop = dragState.startTop + deltaY;
                
                // Use transform for smoother movement
                dragState.overlay.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                
            } else if (dragState.isResizing) {
                // Update size and position based on direction
                const direction = dragState.resizeDirection;
                let newLeft = dragState.startLeft;
                let newTop = dragState.startTop;
                let newWidth = dragState.startWidth;
                let newHeight = dragState.startHeight;
                
                if (direction.includes('n')) {
                    newTop = dragState.startTop + deltaY;
                    newHeight = dragState.startHeight - deltaY;
                }
                if (direction.includes('s')) {
                    newHeight = dragState.startHeight + deltaY;
                }
                if (direction.includes('w')) {
                    newLeft = dragState.startLeft + deltaX;
                    newWidth = dragState.startWidth - deltaX;
                }
                if (direction.includes('e')) {
                    newWidth = dragState.startWidth + deltaX;
                }
                
                // Boundary and size constraints
                if (!displayInfo) return;
                
                const { actualDisplayWidth, actualDisplayHeight, offsetX, offsetY } = displayInfo;
                const minLeft = offsetX;
                const minTop = offsetY;
                const maxRight = offsetX + actualDisplayWidth;
                const maxBottom = offsetY + actualDisplayHeight;
                
                // Minimum and maximum size constraints
                if (newWidth < 20) newWidth = 20;
                if (newHeight < 20) newHeight = 20;
                
                // Boundary constraints - prevent overlay from going outside actual image area
                if (newLeft < minLeft) {
                    newWidth += (newLeft - minLeft); // Reduce width by the amount it extends left
                    newLeft = minLeft;
                }
                if (newTop < minTop) {
                    newHeight += (newTop - minTop); // Reduce height by the amount it extends up
                    newTop = minTop;
                }
                if (newLeft + newWidth > maxRight) {
                    newWidth = maxRight - newLeft; // Trim width to fit
                }
                if (newTop + newHeight > maxBottom) {
                    newHeight = maxBottom - newTop; // Trim height to fit
                }
                
                // Final minimum size check after boundary adjustments
                if (newWidth < 20) newWidth = 20;
                if (newHeight < 20) newHeight = 20;
                
                dragState.overlay.style.left = newLeft + 'px';
                dragState.overlay.style.top = newTop + 'px';
                dragState.overlay.style.width = newWidth + 'px';
                dragState.overlay.style.height = newHeight + 'px';
                
                // Update blur preview
                const currentBlur = document.getElementById('blurStrength')?.value || 10;
                updateCanvasBlurPreview(dragState.overlay, parseInt(currentBlur));
            }
        }
        
        function handleMouseUp(e) {
            const wasDragging = dragState.isDragging;
            const wasResizing = dragState.isResizing;
            const overlay = dragState.overlay;
            
            // Get display info for coordinate conversions
            const displayInfo = getImageDisplayInfo();
            
            if (wasDragging) {
                console.log('Finished dragging');
                overlay.classList.remove('dragging');
                
                // Convert transform back to actual position
                const deltaX = e.clientX - dragState.startX;
                const deltaY = e.clientY - dragState.startY;
                
                if (Math.abs(deltaX) < 5 && Math.abs(deltaY) < 5) {
                    // This was a click, not a drag - toggle blur
                    const part = overlay.dataset.part;
                    console.log('Click detected on overlay, toggling blur for:', part);
                    toggleBlur(part);
                } else {
                    // This was a real drag - update actual position with boundary constraints
                    if (!displayInfo) return;
                    
                    const { actualDisplayWidth, actualDisplayHeight, offsetX, offsetY } = displayInfo;
                    const overlayWidth = parseInt(overlay.style.width);
                    const overlayHeight = parseInt(overlay.style.height);
                    
                    // Calculate boundaries (actual image display area)
                    const minLeft = offsetX;
                    const minTop = offsetY;
                    const maxLeft = offsetX + actualDisplayWidth - overlayWidth;
                    const maxTop = offsetY + actualDisplayHeight - overlayHeight;
                    
                    // Constrain position within actual image boundaries
                    const newLeft = Math.max(minLeft, Math.min(maxLeft, dragState.startLeft + deltaX));
                    const newTop = Math.max(minTop, Math.min(maxTop, dragState.startTop + deltaY));
                    
                    overlay.style.left = newLeft + 'px';
                    overlay.style.top = newTop + 'px';
                    
                    // Convert display coordinates back to original image coordinates  
                    if (displayInfo) {
                        const { offsetX: dragOffsetX, offsetY: dragOffsetY, scaleX, scaleY } = displayInfo;
                        overlay.dataset.originalX = Math.round((newLeft - dragOffsetX) / scaleX);
                        overlay.dataset.originalY = Math.round((newTop - dragOffsetY) / scaleY);
                    }
                    
                    // Update the canvas blur preview with new position
                    const currentBlur = document.getElementById('blurStrength')?.value || 10;
                    updateCanvasBlurPreview(overlay, parseInt(currentBlur));
                }
                
                // Clear transform
                overlay.style.transform = '';
            } else if (wasResizing) {
                console.log('Finished resizing');
                // Convert display coordinates back to original image coordinates  
                if (displayInfo) {
                    const { offsetX, offsetY, scaleX, scaleY } = displayInfo;
                    overlay.dataset.originalX = Math.round((parseInt(overlay.style.left) - offsetX) / scaleX);
                    overlay.dataset.originalY = Math.round((parseInt(overlay.style.top) - offsetY) / scaleY);
                    overlay.dataset.originalWidth = Math.round(parseInt(overlay.style.width) / scaleX);
                    overlay.dataset.originalHeight = Math.round(parseInt(overlay.style.height) / scaleY);
                }
                
                // Update the canvas blur preview with new size/position
                const currentBlur = document.getElementById('blurStrength')?.value || 10;
                updateCanvasBlurPreview(overlay, parseInt(currentBlur));
            }
            
            // Reset drag state
            dragState.isDragging = false;
            dragState.isResizing = false;
            dragState.overlay = null;
            dragState.resizeDirection = null;
            
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
        }
        
        function toggleBlur(part) {
            console.log(`Toggle blur called for: ${part}`);
            console.log(`Current blur state: ${blurStates[part]}`);
            
            blurStates[part] = !blurStates[part];
            const overlay = document.getElementById(`overlay-${part}`);
            const violation = document.getElementById(`violation-${part}`);
            const button = document.getElementById(`btn-${part}`);
            
            console.log(`New blur state: ${blurStates[part]}`);
            console.log(`Found elements:`, { overlay, violation, button });
            
            if (blurStates[part]) {
                // Enable blur
                overlay.classList.remove('disabled');
                violation.classList.remove('approved');
                violation.classList.add('blurred');
                button.innerHTML = 'üü¶ Blurred';
                console.log(`Enabled blur for ${part}`);
            } else {
                // Disable blur
                overlay.classList.add('disabled');
                violation.classList.remove('blurred');
                violation.classList.add('approved');
                button.innerHTML = '‚úÖ Approved';
                console.log(`Disabled blur for ${part}`);
            }
        }
        
        function updateCanvasBlurPreview(overlay, blurStrength) {
            if (!overlay) {
                return;
            }
            
            // Remove any existing canvas
            const existingCanvas = overlay.querySelector('.blur-preview-canvas');
            if (existingCanvas) {
                existingCanvas.remove();
            }
            
            // Apply CSS backdrop-filter blur for preview
            if (blurStrength > 0) {
                // CSS backdrop-filter is much weaker than Sharp.js Gaussian blur
                // Use a multiplier to make the preview more representative of final result
                const cssBlurIntensity = Math.min(100, blurStrength * 2.5); // Cap at 100px for performance
                const opacity = Math.min(0.2, blurStrength / 100); // Much lighter overlay to match Sharp.js
                
                overlay.style.backdropFilter = `blur(${cssBlurIntensity}px)`;
                overlay.style.backgroundColor = `rgba(255, 255, 255, ${opacity})`;
                
                console.log(`Applied ${cssBlurIntensity}px backdrop-filter (from ${blurStrength}px backend) to ${overlay.dataset.part}`);
            } else {
                overlay.style.backdropFilter = 'none';
                overlay.style.backgroundColor = 'rgba(200, 200, 200, 0.2)';
            }
        }

        function applyGaussianBlur(ctx, width, height, radius) {
            // Simple fallback - not used in current implementation
            return;
        }

        function boxBlur(data, width, height, radius) {
            // Simple fallback - not used in current implementation
            return;
        }
        
        function syncAllBlurPreviews() {
            const strength = parseInt(document.getElementById('blurStrength')?.value || 10);
            document.querySelectorAll('.blur-overlay').forEach(overlay => {
                console.log(`üîÅ Syncing blur for: ${overlay.dataset.part}`);
                updateCanvasBlurPreview(overlay, strength);
            });
        }

        // Sharp.js Preview Toggle
        let isPreviewMode = true; // Default to preview mode (eye open)
        let originalImageSrc = null;

        async function toggleSharpPreview() {
            const eyeIcon = document.getElementById('previewEyeToggle');
            const imageElement = document.querySelector('.image-preview');
            
            if (!imageElement) {
                return; // No alert needed, just return
            }

            if (isPreviewMode) {
                // Exit preview mode - hide CSS blur and show overlays normally
                eyeIcon.innerHTML = '‚ö´'; // Closed eye (simple black circle)
                eyeIcon.title = 'Show blur preview';
                
                // Remove CSS blur from active overlays
                document.querySelectorAll('.blur-overlay').forEach(overlay => {
                    const part = overlay.dataset.part;
                    if (blurStates[part]) {
                        overlay.style.backdropFilter = 'none';
                        overlay.style.backgroundColor = 'rgba(255, 255, 255, 0.3)';
                    }
                    overlay.style.display = 'block';
                });
                
                isPreviewMode = false;
                console.log('‚úÖ Exited blur preview mode - showing normal overlays');
                
            } else {
                // Enter preview mode - apply CSS blur to active overlays
                eyeIcon.innerHTML = '‚óè'; // Open eye (simple white circle)
                eyeIcon.title = 'Hide blur preview';
                
                const userStrength = parseInt(document.getElementById('blurStrength').value) || 3;
                
                // Convert 1-10 scale to backend values and then to CSS
                const backendStrength = Math.round(userStrength * 8 + 2);
                const cssCalibrationFactor = 5.5;
                const cssBlurStrength = Math.max(1, Math.round(backendStrength / cssCalibrationFactor));
                
                console.log('üîç Applying CSS blur preview:');
                console.log(`  - User setting: ${userStrength}`);
                console.log(`  - Backend: ${backendStrength}px`);
                console.log(`  - CSS preview: ${cssBlurStrength}px`);
                
                // Apply CSS blur to active overlays only
                document.querySelectorAll('.blur-overlay').forEach(overlay => {
                    const part = overlay.dataset.part;
                    if (blurStates[part]) {
                        // Apply calibrated CSS blur to match Sharp.js intensity
                        overlay.style.backdropFilter = `blur(${cssBlurStrength}px)`;
                        overlay.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                        console.log(`Applied ${cssBlurStrength}px CSS blur to ${part} (matches ${blurStrength}px Sharp.js)`);
                    } else {
                        // Hide inactive overlays in preview mode
                        overlay.style.display = 'none';
                    }
                });
                
                isPreviewMode = true;
                console.log('‚úÖ CSS blur preview activated');
            }
        }

        function activateInitialPreview() {
            const userStrength = parseInt(document.getElementById('blurStrength').value) || 3;
            const backendStrength = Math.round(userStrength * 8 + 2);
            const cssCalibrationFactor = 5.5;
            const cssBlurStrength = Math.max(1, Math.round(backendStrength / cssCalibrationFactor));
            
            console.log('üîç Activating initial preview mode');
            
            // Apply CSS blur to active overlays
            document.querySelectorAll('.blur-overlay').forEach(overlay => {
                const part = overlay.dataset.part;
                if (blurStates[part]) {
                    overlay.style.backdropFilter = `blur(${cssBlurStrength}px)`;
                    overlay.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                }
            });
        }

        function updateBlurSettings() {
            const userStrength = parseInt(document.getElementById('blurStrength').value);
            const shape = document.getElementById('blurShape').value;
            
            // Convert 1-10 scale to backend values (roughly 8-80px range)
            const backendStrength = Math.round(userStrength * 8 + 2); // 1->10px, 10->82px
            
            // Calculate CSS blur strength for preview
            const cssCalibrationFactor = 5.5;
            const cssBlurStrength = Math.max(1, Math.round(backendStrength / cssCalibrationFactor));
            
            document.getElementById('blurStrengthValue').textContent = userStrength;
            
            console.log(`Blur settings: user=${userStrength}, backend=${backendStrength}px, CSS preview=${cssBlurStrength}px, shape=${shape}`);
            
            // If in preview mode, update the CSS blur in real-time
            if (isPreviewMode) {
                console.log(`üîÑ Updating CSS blur preview: user ${userStrength} ‚Üí ${cssBlurStrength}px CSS`);
                
                document.querySelectorAll('.blur-overlay').forEach(overlay => {
                    const part = overlay.dataset.part;
                    if (blurStates[part]) {
                        overlay.style.backdropFilter = `blur(${cssBlurStrength}px)`;
                        console.log(`Updated ${part} blur preview to ${cssBlurStrength}px`);
                    }
                });
            }
            
            // Update all blur overlays with real-time preview
            document.querySelectorAll('.blur-overlay').forEach(overlay => {
                const part = overlay.dataset.part;
                
                // Debug logging to track overlay dimensions
                console.log(`Overlay ${part}:`, overlay.style.left, overlay.style.top, overlay.style.width, overlay.style.height);
                
                // Update blur preview in real-time
                updateCanvasBlurPreview(overlay, backendStrength);
                
                // Remove existing shape classes
                overlay.classList.remove('shape-square', 'shape-rounded', 'shape-oval');
                
                // Add new shape class
                overlay.classList.add(`shape-${shape}`);
            });
        }
        
        let manualBlurCounter = 0;
        
        function addManualBlurArea() {
            const displayInfo = getImageDisplayInfo();
            if (!displayInfo) {
                alert('Please upload and analyze an image first');
                return;
            }
            
            manualBlurCounter++;
            const partName = `manual_blur_${manualBlurCounter}`;
            
            const { actualDisplayWidth, actualDisplayHeight, offsetX, offsetY, scaleX, scaleY } = displayInfo;
            
            // Create a default blur area in the center of the actual image area
            const defaultWidth = Math.min(200, actualDisplayWidth * 0.3);
            const defaultHeight = Math.min(150, actualDisplayHeight * 0.3);
            const defaultX = offsetX + (actualDisplayWidth - defaultWidth) / 2;
            const defaultY = offsetY + (actualDisplayHeight - defaultHeight) / 2;
            
            // Convert to original image coordinates
            const originalX = Math.round((defaultX - offsetX) / scaleX);
            const originalY = Math.round((defaultY - offsetY) / scaleY);
            const originalWidth = Math.round(defaultWidth / scaleX);
            const originalHeight = Math.round(defaultHeight / scaleY);
            
            // Create overlay HTML
            const overlayId = `overlay-${partName}`;
            const overlayHtml = `
                <div id="${overlayId}" 
                     class="blur-overlay shape-square" 
                     data-original-x="${originalX}"
                     data-original-y="${originalY}"
                     data-original-width="${originalWidth}"
                     data-original-height="${originalHeight}"
                     data-part="${partName}"
                     style="
                         left: ${defaultX}px; 
                         top: ${defaultY}px; 
                         width: ${defaultWidth}px; 
                         height: ${defaultHeight}px;
                         --blur-strength: 10px;
                         z-index: 10;
                     ">
                    <canvas class="blur-preview-canvas" width="${defaultWidth}" height="${defaultHeight}"></canvas>
                    <div class="violation-label">MANUAL BLUR ${manualBlurCounter}</div>
                    
                    <!-- Resize Handles -->
                    <div class="resize-handle nw" data-direction="nw"></div>
                    <div class="resize-handle ne" data-direction="ne"></div>
                    <div class="resize-handle sw" data-direction="sw"></div>
                    <div class="resize-handle se" data-direction="se"></div>
                    <div class="resize-handle n" data-direction="n"></div>
                    <div class="resize-handle s" data-direction="s"></div>
                    <div class="resize-handle w" data-direction="w"></div>
                    <div class="resize-handle e" data-direction="e"></div>
                </div>
            `;
            
            // Add to image container
            const imageContainer = document.querySelector('.image-container');
            imageContainer.insertAdjacentHTML('beforeend', overlayHtml);
            
            // Initialize the new overlay
            const newOverlay = document.getElementById(overlayId);
            blurStates[partName] = true;
            
            // Initialize drag/resize and canvas blur
            setTimeout(() => {
                initializeDragResize(newOverlay);
                updateCanvasBlurPreview(newOverlay, parseInt(document.getElementById('blurStrength').value || 10));
            }, 100);
            
            // Add to violations list
            const violationsContent = document.getElementById('violationsContent');
            const violationHtml = `
                <div id="violation-${partName}" class="violation-item blurred">
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <strong>MANUAL BLUR ${manualBlurCounter}</strong>
                            <br><small>Manual blur area | Location: ${Math.round(defaultX)}, ${Math.round(defaultY)}</small>
                        </div>
                        <div>
                            <button class="btn btn-sm btn-outline-primary" onclick="toggleBlur('${partName}')">
                                <span id="btn-${partName}">üü¶ Blurred</span>
                            </button>
                            <button class="btn btn-sm btn-outline-danger" onclick="removeManualBlurArea('${partName}')">
                                üóëÔ∏è
                            </button>
                        </div>
                    </div>
                </div>
            `;
            violationsContent.insertAdjacentHTML('beforeend', violationHtml);
            
            console.log(`Added manual blur area: ${partName}`);
        }
        
        function removeManualBlurArea(partName) {
            if (confirm('Remove this blur area?')) {
                // Remove overlay
                const overlay = document.getElementById(`overlay-${partName}`);
                if (overlay) overlay.remove();
                
                // Remove from violations list
                const violation = document.getElementById(`violation-${partName}`);
                if (violation) violation.remove();
                
                // Remove from blur states
                delete blurStates[partName];
                
                console.log(`Removed manual blur area: ${partName}`);
            }
        }
        
        function toggleAllBlurs() {
            const allBlurred = Object.values(blurStates).every(state => state);
            
            Object.keys(blurStates).forEach(part => {
                if (allBlurred) {
                    // If all are blurred, approve all
                    if (blurStates[part]) toggleBlur(part);
                } else {
                    // If not all are blurred, blur all
                    if (!blurStates[part]) toggleBlur(part);
                }
            });
        }
        
        function displayAnalysisResults(analysis) {
            const content = `
                <div class="row">
                    <div class="col-md-6">
                        <div class="badge bg-${analysis.moderation_status === 'approved' ? 'success' : 'danger'} fs-6">
                            ${analysis.moderation_status.toUpperCase()}
                        </div>
                        <br><small>Moderation Status</small>
                    </div>
                    <div class="col-md-6">
                        <div class="badge bg-warning fs-6">${analysis.nudity_score.toFixed(1)}%</div>
                        <br><small>Nudity Score</small>
                    </div>
                </div>
                
                <div class="mt-3">
                    <strong>Pose Classification:</strong> ${analysis.pose_category || 'Unknown'}<br>
                    <strong>Risk Level:</strong> ${analysis.risk_level || 'Unknown'}<br>
                    <strong>Final Risk Score:</strong> ${analysis.final_risk_score ? analysis.final_risk_score.toFixed(1) + '%' : 'N/A'}
                </div>
            `;
            
            document.getElementById('analysisContent').innerHTML = content;
            document.getElementById('analysisResults').style.display = 'block';
        }
        
        async function saveModeratedImage() {
            if (!analysisData) {
                alert('No image to save');
                return;
            }
            
            if (!analysisData.content_moderation_id) {
                alert('Error: No content moderation ID found');
                return;
            }
            
            // Collect current blur settings and overlay positions
            const blurredParts = Object.entries(blurStates)
                .filter(([part, isBlurred]) => isBlurred)
                .map(([part]) => part);
            
            if (blurredParts.length === 0) {
                if (!confirm('No blur effects applied. Continue with approval?')) {
                    return;
                }
            }
            
            // Collect current overlay positions and transform for backend processing
            const overlayPositions = {};
            document.querySelectorAll('.blur-overlay').forEach(overlay => {
                const part = overlay.dataset.part;
                if (blurStates[part]) { // Only include active blur areas
                    const displayCoords = {
                        x: parseFloat(overlay.dataset.originalX),
                        y: parseFloat(overlay.dataset.originalY),
                        width: parseFloat(overlay.dataset.originalWidth),
                        height: parseFloat(overlay.dataset.originalHeight)
                    };
                    
                    console.log(`DEBUG: Display coordinates for ${part}:`, displayCoords);
                    console.log(`DEBUG: Image natural dimensions: ${currentImage.naturalWidth}x${currentImage.naturalHeight}`);
                    
                    // Debug container size vs natural size
                    const imageElement = document.querySelector('.image-preview');
                    const containerWidth = imageElement.clientWidth;
                    const containerHeight = imageElement.clientHeight;
                    console.log(`DEBUG: Container dimensions: ${containerWidth}x${containerHeight}`);
                    console.log(`DEBUG: ScaleX:`, currentImage.naturalWidth / containerWidth);
                    console.log(`DEBUG: ScaleY:`, currentImage.naturalHeight / containerHeight);
                    
                    // Backend now uses normalized images, so coordinates need to match
                    // For now, assume no additional transformation needed since backend normalizes the image
                    // and coordinates are already in natural image pixel space
                    const backendCoords = {
                        x: displayCoords.x,
                        y: displayCoords.y, 
                        width: displayCoords.width,
                        height: displayCoords.height
                    };
                    
                    // Verify coordinates are in natural image space
                    const scaleX = currentImage.naturalWidth / containerWidth;
                    const scaleY = currentImage.naturalHeight / containerHeight;
                    
                    console.log(`DEBUG: Coordinate verification for ${part}:`);
                    console.log(`  Display coords: x=${displayCoords.x}, y=${displayCoords.y}, w=${displayCoords.width}, h=${displayCoords.height}`);
                    console.log(`  Scale factors: scaleX=${scaleX.toFixed(3)}, scaleY=${scaleY.toFixed(3)}`);
                    console.log(`  Should be natural coords: x=${displayCoords.x}, y=${displayCoords.y} (already scaled)`);
                    console.log(`  As percentage of image: x=${(displayCoords.x/currentImage.naturalWidth*100).toFixed(1)}%, y=${(displayCoords.y/currentImage.naturalHeight*100).toFixed(1)}%`);
                    
                    console.log(`DEBUG: Backend coordinates for ${part}:`, backendCoords);
                    overlayPositions[part] = backendCoords;
                }
            });
            
            // Convert 1-10 user scale to backend pixel values (matching updateBlurSettings logic)
            const userStrength = parseInt(document.getElementById('blurStrength').value);
            const backendStrength = Math.round(userStrength * 8 + 2); // 1->10px, 10->82px
            
            const blurSettings = {
                strength: backendStrength, // Send backend pixel values, not user scale
                shape: document.getElementById('blurShape').value,
                blurredParts: blurredParts,
                overlayPositions: overlayPositions
            };
            
            const adminNotes = prompt('Add approval notes (optional):') || '';
            
            console.log('Saving moderated image with blur settings:', blurSettings);
            
            // DEBUG: Log coordinate data
            console.log('DEBUG: Current image dimensions:', currentImage.naturalWidth, 'x', currentImage.naturalHeight);
            const imageElement = document.querySelector('.image-preview');
            console.log('DEBUG: Display dimensions:', imageElement.clientWidth, 'x', imageElement.clientHeight);
            
            // Show loading state
            const saveButton = document.querySelector('button[onclick="saveModeratedImage()"]');
            const originalText = saveButton.innerHTML;
            saveButton.innerHTML = '‚è≥ Saving...';
            saveButton.disabled = true;
            
            try {
                console.log('üöÄ Sending blur approval request...');
                console.log('Content Moderation ID:', analysisData.content_moderation_id);
                console.log('Blur Settings:', blurSettings);
                
                const requestBody = {
                    content_moderation_id: analysisData.content_moderation_id,
                    blur_settings: blurSettings,
                    admin_notes: adminNotes,
                    reviewed_by: 1 // TODO: Get actual admin user ID from session
                };
                console.log('Request body:', JSON.stringify(requestBody, null, 2));
                
                const response = await fetch('/api/enhanced-content-moderation/admin/approve-with-blur', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });
                
                console.log('Response status:', response.status);
                console.log('Response headers:', response.headers);
                
                const result = await response.json();
                console.log('Response body:', result);
                
                if (result.success) {
                    const modelSelect = document.getElementById('modelSelect');
                    const selectedModel = modelSelect.value ? JSON.parse(modelSelect.value) : null;
                    const modelName = selectedModel ? selectedModel.name : 'Unknown Model';
                    
                    alert(`‚úÖ Image saved successfully with blur settings!
                    
Model: ${modelName}
Blurred parts: ${blurSettings.blurredParts.join(', ') || 'None'}
Blur strength: ${blurSettings.strength}
Shape: ${blurSettings.shape}

The blurred version has been saved to the blurred folder.`);
                    
                    // Reset form
                    document.getElementById('imageUpload').value = '';
                    document.getElementById('imageContainer').innerHTML = `
                        <div class="text-muted py-5">
                            <i class="bi bi-image" style="font-size: 4rem;"></i>
                            <h4>Upload an image to begin review</h4>
                        </div>
                    `;
                    document.getElementById('blurControls').style.display = 'none';
                    document.getElementById('violationsList').style.display = 'none';
                    document.getElementById('analysisResults').style.display = 'none';
                    
                } else {
                    console.error('‚ùå API returned error:', result.error);
                    throw new Error(result.error || 'Unknown error occurred');
                }
                
            } catch (error) {
                console.error('‚ùå Error saving moderated image:', error);
                
                // Check for specific error types
                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    alert(`‚ùå Network Error: Unable to connect to server. Please check your connection and try again.`);
                } else if (error.message.includes('content_moderation_id')) {
                    alert(`‚ùå Data Error: Missing content moderation ID. Please reload the page and try again.`);
                } else {
                    alert(`‚ùå Error saving image: ${error.message}\n\nCheck the browser console for more details.`);
                }
            } finally {
                // Restore button state
                const saveButton = document.querySelector('button[onclick="saveModeratedImage()"]');
                saveButton.innerHTML = originalText;
                saveButton.disabled = false;
            }
        }
        
        function rejectImage() {
            if (!analysisData) {
                alert('No image to reject');
                return;
            }
            
            if (confirm('Are you sure you want to reject this image?')) {
                const rejectionData = {
                    analysis: analysisData,
                    adminDecision: 'rejected',
                    reason: 'Administrative review'
                };
                
                console.log('Rejecting image:', rejectionData);
                alert('Image rejected by admin review');
            }
        }
        
        // Load available models when page loads
        async function loadModels() {
            try {
                const response = await fetch('/api/admin-models');
                const data = await response.json();
                
                const modelSelect = document.getElementById('modelSelect');
                modelSelect.innerHTML = '<option value="">Select a model...</option>';
                
                if (data.success && data.models) {
                    data.models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = JSON.stringify({
                            id: model.id,
                            name: model.name,
                            slug: model.slug
                        });
                        option.textContent = `${model.name} (${model.model_type})`;
                        modelSelect.appendChild(option);
                    });
                    
                    // Enable analyze button once models are loaded
                    document.getElementById('analyzeButton').disabled = false;
                } else {
                    modelSelect.innerHTML = '<option value="">Error loading models</option>';
                }
            } catch (error) {
                console.error('Error loading models:', error);
                const modelSelect = document.getElementById('modelSelect');
                modelSelect.innerHTML = '<option value="">Error loading models</option>';
            }
        }
        
        // Enable/disable analyze button based on model selection
        document.getElementById('modelSelect').addEventListener('change', function() {
            const analyzeButton = document.getElementById('analyzeButton');
            analyzeButton.disabled = !this.value;
        });
        
        // Handle window resize to rescale overlays
        window.addEventListener('resize', function() {
            if (currentImage && analysisData && analysisData.part_locations) {
                setTimeout(scaleOverlays, 100);
            }
        });
        
        // Load models when page loads
        document.addEventListener('DOMContentLoaded', function() {
            loadModels();
        });

        // URL Parameter handling for Media Queue integration
        let mediaQueueMode = false;
        let currentMediaId = null;

        function getUrlParams() {
            const urlParams = new URLSearchParams(window.location.search);
            return {
                mediaId: urlParams.get('mediaId'),
                imagePath: urlParams.get('imagePath'),
                modelName: urlParams.get('modelName'),
                autoLoad: urlParams.get('autoLoad') === 'true'
            };
        }

        // Auto-load functionality for Media Queue integration
        document.addEventListener('DOMContentLoaded', function() {
            const params = getUrlParams();
            
            if (params.autoLoad && params.mediaId && params.imagePath) {
                mediaQueueMode = true;
                currentMediaId = params.mediaId;
                
                // Update page title
                document.title = `üõ°Ô∏è Blur Review - ${params.modelName || 'Media Item'}`;
                
                // Auto-load the image
                loadMediaQueueImage(params.imagePath, params.mediaId);
                
                // Update button text for Media Queue context
                updateButtonsForMediaQueue();
            }
        });

        async function loadMediaQueueImage(imagePath, mediaId) {
            try {
                // Convert absolute path to web-accessible path
                const webPath = imagePath.replace('/Users/programmer/Projects/musenest/public', '');
                
                // Create image element
                const img = new Image();
                img.onload = function() {
                    currentImage = img;
                    document.getElementById('imagePreview').innerHTML = '';
                    document.getElementById('imagePreview').appendChild(img);
                    
                    // Auto-analyze the image
                    analyzeImageFromMediaQueue(mediaId);
                };
                
                img.onerror = function() {
                    console.error('Failed to load image:', webPath);
                    alert('Failed to load image. Please check the file path.');
                };
                
                img.src = webPath;
                img.style.maxWidth = '100%';
                img.style.height = 'auto';
                
            } catch (error) {
                console.error('Error loading media queue image:', error);
                alert('Error loading image: ' + error.message);
            }
        }

        async function analyzeImageFromMediaQueue(mediaId) {
            try {
                // Get the analysis data from the media queue API
                const response = await fetch(`/api/media-review-queue/item/${mediaId}`);
                const data = await response.json();
                
                if (data.success) {
                    const item = data.item;
                    
                    // Store the file path for preview generation
                    currentUploadedFilePath = item.file_path;
                    console.log('üìÅ Stored media queue file path:', currentUploadedFilePath);
                    
                    // Convert the media queue data to the expected analysis format
                    analysisData = {
                        nudity_score: item.nudity_score,
                        detected_parts: item.detected_parts,
                        part_locations: item.part_locations,
                        pose_classification: item.pose_classification,
                        explicit_pose_score: item.explicit_pose_score,
                        generated_caption: `Media content from ${item.model_name}`,
                        moderation_status: item.review_status === 'pending' ? 'flagged' : item.review_status
                    };
                    
                    // Display analysis results
                    displayAnalysisResults(analysisData);
                    
                    // Create blur overlays if there are part locations
                    if (analysisData.part_locations && Object.keys(analysisData.part_locations).length > 0) {
                        createBlurOverlays(analysisData.part_locations);
                    } else {
                        // If no specific locations, create overlays based on detected parts
                        createDefaultOverlaysFromDetectedParts(analysisData.detected_parts);
                    }
                    
                } else {
                    throw new Error(data.error || 'Failed to get media analysis');
                }
                
            } catch (error) {
                console.error('Error analyzing media queue image:', error);
                alert('Error analyzing image: ' + error.message);
            }
        }

        function createDefaultOverlaysFromDetectedParts(detectedParts) {
            if (!detectedParts || Object.keys(detectedParts).length === 0) return;
            
            // Create default overlay positions for detected parts
            const defaultPositions = {
                'genitalia': { x: 0.4, y: 0.6, width: 0.2, height: 0.3 },
                'breasts': { x: 0.35, y: 0.3, width: 0.3, height: 0.3 },
                'buttocks': { x: 0.3, y: 0.5, width: 0.4, height: 0.4 },
                'anus': { x: 0.45, y: 0.65, width: 0.1, height: 0.1 }
            };
            
            const partLocations = {};
            Object.keys(detectedParts).forEach(part => {
                if (defaultPositions[part]) {
                    partLocations[part] = defaultPositions[part];
                }
            });
            
            if (Object.keys(partLocations).length > 0) {
                createBlurOverlays(partLocations);
            }
        }

        function updateButtonsForMediaQueue() {
            // Update the save button to integrate with Media Queue
            const saveBtn = document.querySelector('button[onclick="saveModeratedImage()"]');
            if (saveBtn) {
                saveBtn.innerHTML = 'üíæ Approve with Blur Settings';
                saveBtn.onclick = saveMediaQueueBlurApproval;
            }
            
            // Update the reject button
            const rejectBtn = document.querySelector('button[onclick="rejectImage()"]');
            if (rejectBtn) {
                rejectBtn.onclick = rejectMediaQueueImage;
            }
        }

        async function saveMediaQueueBlurApproval() {
            if (!analysisData || !currentMediaId) {
                alert('No media item to approve');
                return;
            }
            
            const blurredParts = Object.entries(blurStates)
                .filter(([part, isBlurred]) => isBlurred)
                .map(([part]) => part);
            
            if (blurredParts.length === 0) {
                if (!confirm('No blur effects applied. Continue with approval?')) {
                    return;
                }
            }
            
            const notes = prompt('Add approval notes (optional):') || '';
            
            // Collect current overlay positions for backend processing
            const overlayPositions = {};
            document.querySelectorAll('.blur-overlay').forEach(overlay => {
                const part = overlay.dataset.part;
                if (blurStates[part]) { // Only include active blur areas
                    overlayPositions[part] = {
                        x: parseFloat(overlay.dataset.originalX),
                        y: parseFloat(overlay.dataset.originalY),
                        width: parseFloat(overlay.dataset.originalWidth),
                        height: parseFloat(overlay.dataset.originalHeight)
                    };
                }
            });
            
            const blurSettings = {
                strength: parseInt(document.getElementById('blurStrength').value),
                shape: document.getElementById('blurShape').value,
                blurredParts: blurredParts,
                overlayPositions: overlayPositions
            };
            
            try {
                const response = await fetch(`/api/media-review-queue/approve-blur/${currentMediaId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        blur_settings: blurSettings,
                        admin_notes: notes,
                        reviewed_by: 1 // TODO: Get actual admin user ID
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Notify parent window (Media Queue) that approval is complete
                    if (window.opener) {
                        window.opener.postMessage({
                            type: 'BLUR_APPROVAL_COMPLETE',
                            mediaId: currentMediaId,
                            blurSettings: blurSettings
                        }, window.location.origin);
                    }
                    
                    alert('Media approved with blur settings successfully!');
                    window.close();
                } else {
                    throw new Error(data.error || 'Failed to approve media');
                }
                
            } catch (error) {
                console.error('Error approving media with blur:', error);
                alert('Error approving media: ' + error.message);
            }
        }

        async function rejectMediaQueueImage() {
            if (!currentMediaId) {
                alert('No media item to reject');
                return;
            }
            
            const reason = prompt('Reason for rejection (required):');
            if (!reason || !reason.trim()) {
                alert('Rejection reason is required');
                return;
            }
            
            if (!confirm('Are you sure you want to reject this media?')) {
                return;
            }
            
            try {
                const response = await fetch(`/api/media-review-queue/reject/${currentMediaId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        admin_notes: reason,
                        reviewed_by: 1 // TODO: Get actual admin user ID
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Notify parent window that rejection is complete
                    if (window.opener) {
                        window.opener.postMessage({
                            type: 'BLUR_APPROVAL_COMPLETE', // Same message type to refresh queue
                            mediaId: currentMediaId,
                            action: 'rejected'
                        }, window.location.origin);
                    }
                    
                    alert('Media rejected successfully!');
                    window.close();
                } else {
                    throw new Error(data.error || 'Failed to reject media');
                }
                
            } catch (error) {
                console.error('Error rejecting media:', error);
                alert('Error rejecting media: ' + error.message);
            }
        }
        
        /**
         * Reset blur controls to their default state when a new image loads
         */
        function resetBlurControlsToDefault() {
            // Reset shape dropdown to Rectangle (default from nudenet detection boxes)
            const shapeSelect = document.getElementById('blurShape');
            if (shapeSelect) {
                shapeSelect.value = 'square'; // Rectangle is the default shape
            }
            
            // Reset blur strength to default value if needed
            const blurStrength = document.getElementById('blurStrength');
            if (blurStrength) {
                blurStrength.value = 3; // Default blur strength
            }
            
            console.log('üîÑ Reset blur controls to default state');
        }
        
        // üß™ Optional: Add Debug After Page Load
        window.addEventListener('load', () => {
            console.log("üîç Forcing initial canvas sync after page load...");
            syncAllBlurPreviews();
            
            // Initialize blur display values
            updateBlurSettings();
        });
    </script>
    <script src="https://cdn.jsdelivr.net/npm/blueimp-load-image@5.16.0/js/load-image.all.min.js"></script>
</body>
</html>