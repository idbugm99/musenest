/**
 * Penetration Testing and Vulnerability Assessment Service
 * Part of Phase F.6: Add penetration testing and vulnerability assessment
 * Provides comprehensive vulnerability scanning, penetration testing, and security assessment capabilities
 */

const EventEmitter = require('events');
const crypto = require('crypto');

class VulnerabilityAssessmentService extends EventEmitter {
    constructor(db, securityService, incidentService, config = {}) {
        super();
        this.db = db;
        this.securityService = securityService;
        this.incidentService = incidentService;
        
        // Initialize configuration with defaults
        this.configuration = {
            scanning: {
                enableAutomatedScanning: config.scanning?.enableAutomatedScanning !== false,
                scanInterval: config.scanning?.scanInterval || 7 * 24 * 3600000, // Weekly
                enableContinuousScanning: config.scanning?.enableContinuousScanning !== false,
                maxConcurrentScans: config.scanning?.maxConcurrentScans || 5,
                scanTimeout: config.scanning?.scanTimeout || 3600000, // 1 hour
                enableDeepScanning: config.scanning?.enableDeepScanning !== false,
                enableComplianceScanning: config.scanning?.enableComplianceScanning !== false
            },
            assessment: {
                enablePenetrationTesting: config.assessment?.enablePenetrationTesting !== false,
                testingFrequency: config.assessment?.testingFrequency || 30 * 24 * 3600000, // Monthly
                testingDepth: config.assessment?.testingDepth || 'standard', // basic, standard, advanced
                enableRedTeamExercises: config.assessment?.enableRedTeamExercises !== false,
                enableSocialEngineering: config.assessment?.enableSocialEngineering !== false,
                enablePhysicalSecurity: config.assessment?.enablePhysicalSecurity !== false
            },
            vulnerability: {
                severityThresholds: config.vulnerability?.severityThresholds || {
                    critical: 9.0,
                    high: 7.0,
                    medium: 4.0,
                    low: 0.0
                },
                autoRemediation: config.vulnerability?.autoRemediation !== false,
                remediationTimeout: config.vulnerability?.remediationTimeout || 30 * 24 * 3600000, // 30 days
                falsePositiveFiltering: config.vulnerability?.falsePositiveFiltering !== false,
                contextualScoring: config.vulnerability?.contextualScoring !== false
            },
            reporting: {
                enableAutomatedReporting: config.reporting?.enableAutomatedReporting !== false,
                reportFormats: config.reporting?.reportFormats || ['json', 'pdf', 'html', 'xml'],
                executiveReporting: config.reporting?.executiveReporting !== false,
                complianceReporting: config.reporting?.complianceReporting !== false,
                trendAnalysis: config.reporting?.trendAnalysis !== false,
                benchmarking: config.reporting?.benchmarking !== false
            },
            integration: {
                enableCVEIntegration: config.integration?.enableCVEIntegration !== false,
                enableNVDIntegration: config.integration?.enableNVDIntegration !== false,
                enableOWASPIntegration: config.integration?.enableOWASPIntegration !== false,
                threatIntelligenceIntegration: config.integration?.threatIntelligenceIntegration !== false,
                ticketSystemIntegration: config.integration?.ticketSystemIntegration !== false
            },
            remediation: {
                enableAutomatedRemediation: config.remediation?.enableAutomatedRemediation !== false,
                autoApplyPatches: config.remediation?.autoApplyPatches !== false,
                testPatchesFirst: config.remediation?.testPatchesFirst !== false,
                rollbackCapability: config.remediation?.rollbackCapability !== false,
                changeManagementIntegration: config.remediation?.changeManagementIntegration !== false
            }
        };

        // Initialize internal state
        this.isActive = true;
        this.scanQueue = [];
        this.activeScans = new Map(); // scanId -> scan data
        this.vulnerabilities = new Map(); // vulnerabilityId -> vulnerability data
        this.assessments = new Map(); // assessmentId -> assessment data
        this.penetrationTests = new Map(); // testId -> test data
        this.remediationTasks = new Map(); // taskId -> remediation task
        this.reports = new Map(); // reportId -> report data
        this.scanTargets = new Map(); // targetId -> target configuration
        this.scanPolicies = new Map(); // policyId -> policy configuration
        this.exploitDatabase = new Map(); // exploitId -> exploit data
        this.complianceChecks = new Map(); // checkId -> compliance check

        // Initialize default scan targets and policies
        this.initializeScanTargets();
        this.initializeScanPolicies();
        this.initializeExploitDatabase();
        this.initializeComplianceChecks();

        // Start periodic operations
        this.startPeriodicOperations();

        console.log('üîç VulnerabilityAssessmentService initialized');
    }

    /**
     * Initialize default scan targets
     */
    initializeScanTargets() {
        const defaultTargets = [
            {
                id: 'web_application',
                name: 'Web Application',
                type: 'web_app',
                url: 'https://musenest.com',
                endpoints: ['/api', '/admin', '/upload', '/user'],
                scanTypes: ['web_vulnerability', 'sql_injection', 'xss', 'csrf', 'authentication'],
                priority: 'high',
                scanFrequency: 7 * 24 * 3600000, // Weekly
                active: true
            },
            {
                id: 'api_endpoints',
                name: 'API Endpoints',
                type: 'api',
                url: 'https://api.musenest.com',
                endpoints: ['/api/v1', '/api/v2'],
                scanTypes: ['api_security', 'authentication', 'authorization', 'input_validation'],
                priority: 'critical',
                scanFrequency: 3 * 24 * 3600000, // 3 days
                active: true
            },
            {
                id: 'infrastructure',
                name: 'Network Infrastructure',
                type: 'infrastructure',
                targets: ['10.0.0.0/24', '192.168.1.0/24'],
                scanTypes: ['port_scan', 'service_detection', 'vulnerability_scan', 'configuration_review'],
                priority: 'high',
                scanFrequency: 14 * 24 * 3600000, // Bi-weekly
                active: true
            },
            {
                id: 'database_systems',
                name: 'Database Systems',
                type: 'database',
                targets: ['mysql://db1.internal', 'mysql://db2.internal'],
                scanTypes: ['database_security', 'access_control', 'encryption_check', 'audit_log_review'],
                priority: 'critical',
                scanFrequency: 7 * 24 * 3600000, // Weekly
                active: true
            },
            {
                id: 'cloud_resources',
                name: 'Cloud Resources',
                type: 'cloud',
                provider: 'aws',
                resources: ['s3', 'ec2', 'rds', 'iam'],
                scanTypes: ['cloud_security', 'iam_review', 'storage_security', 'network_security'],
                priority: 'high',
                scanFrequency: 7 * 24 * 3600000, // Weekly
                active: true
            }
        ];

        defaultTargets.forEach(target => {
            this.scanTargets.set(target.id, {
                ...target,
                createdAt: Date.now(),
                lastScan: null,
                scanCount: 0,
                vulnerabilitiesFound: 0
            });
        });

        console.log(`üîç Initialized ${defaultTargets.length} scan targets`);
    }

    /**
     * Initialize default scan policies
     */
    initializeScanPolicies() {
        const defaultPolicies = [
            {
                id: 'owasp_top_10',
                name: 'OWASP Top 10',
                description: 'Comprehensive scan for OWASP Top 10 vulnerabilities',
                category: 'web_application',
                checks: [
                    'injection_flaws',
                    'broken_authentication',
                    'sensitive_data_exposure',
                    'xml_external_entities',
                    'broken_access_control',
                    'security_misconfiguration',
                    'xss',
                    'insecure_deserialization',
                    'vulnerable_components',
                    'insufficient_logging'
                ],
                severity: 'comprehensive',
                depth: 'deep',
                estimated_duration: 3600000, // 1 hour
                active: true
            },
            {
                id: 'network_security',
                name: 'Network Security Assessment',
                description: 'Comprehensive network security vulnerability assessment',
                category: 'infrastructure',
                checks: [
                    'port_enumeration',
                    'service_fingerprinting',
                    'ssl_tls_assessment',
                    'firewall_bypass',
                    'network_segmentation',
                    'dns_security',
                    'wireless_security'
                ],
                severity: 'comprehensive',
                depth: 'standard',
                estimated_duration: 7200000, // 2 hours
                active: true
            },
            {
                id: 'compliance_pci_dss',
                name: 'PCI DSS Compliance',
                description: 'Payment Card Industry Data Security Standard compliance assessment',
                category: 'compliance',
                checks: [
                    'network_security',
                    'access_control',
                    'encryption_at_rest',
                    'encryption_in_transit',
                    'vulnerability_management',
                    'security_monitoring',
                    'audit_logging',
                    'physical_security',
                    'policy_compliance',
                    'penetration_testing'
                ],
                severity: 'strict',
                depth: 'comprehensive',
                estimated_duration: 14400000, // 4 hours
                active: true
            },
            {
                id: 'cloud_security_aws',
                name: 'AWS Cloud Security',
                description: 'Amazon Web Services cloud security assessment',
                category: 'cloud',
                checks: [
                    'iam_configuration',
                    'security_groups',
                    's3_bucket_security',
                    'encryption_configuration',
                    'logging_monitoring',
                    'vpc_security',
                    'lambda_security',
                    'rds_security'
                ],
                severity: 'comprehensive',
                depth: 'deep',
                estimated_duration: 5400000, // 1.5 hours
                active: true
            }
        ];

        defaultPolicies.forEach(policy => {
            this.scanPolicies.set(policy.id, {
                ...policy,
                createdAt: Date.now(),
                lastUsed: null,
                usageCount: 0,
                avgSuccessRate: 95
            });
        });

        console.log(`üîç Initialized ${defaultPolicies.length} scan policies`);
    }

    /**
     * Initialize exploit database
     */
    initializeExploitDatabase() {
        const sampleExploits = [
            {
                id: 'CVE-2023-12345',
                name: 'SQL Injection in Authentication',
                description: 'SQL injection vulnerability in login form allows authentication bypass',
                severity: 'critical',
                cvssScore: 9.8,
                cveId: 'CVE-2023-12345',
                affectedSystems: ['web_application'],
                exploitAvailable: true,
                publicExploit: false,
                patchAvailable: true,
                category: 'injection',
                vectors: ['network'],
                requirements: ['web_access'],
                impact: { confidentiality: 'high', integrity: 'high', availability: 'high' }
            },
            {
                id: 'CVE-2023-67890',
                name: 'Cross-Site Scripting (XSS)',
                description: 'Reflected XSS vulnerability in search functionality',
                severity: 'high',
                cvssScore: 7.2,
                cveId: 'CVE-2023-67890',
                affectedSystems: ['web_application'],
                exploitAvailable: true,
                publicExploit: true,
                patchAvailable: true,
                category: 'xss',
                vectors: ['network'],
                requirements: ['user_interaction'],
                impact: { confidentiality: 'medium', integrity: 'low', availability: 'none' }
            },
            {
                id: 'CVE-2023-11111',
                name: 'Insecure Direct Object Reference',
                description: 'Users can access other users\' private data through direct object references',
                severity: 'high',
                cvssScore: 7.5,
                cveId: 'CVE-2023-11111',
                affectedSystems: ['web_application', 'api_endpoints'],
                exploitAvailable: true,
                publicExploit: false,
                patchAvailable: false,
                category: 'broken_access_control',
                vectors: ['network'],
                requirements: ['authenticated_access'],
                impact: { confidentiality: 'high', integrity: 'none', availability: 'none' }
            }
        ];

        sampleExploits.forEach(exploit => {
            this.exploitDatabase.set(exploit.id, {
                ...exploit,
                createdAt: Date.now(),
                lastSeen: Date.now(),
                exploitAttempts: 0,
                remediated: false
            });
        });

        console.log(`üîç Initialized ${sampleExploits.length} exploit entries`);
    }

    /**
     * Initialize compliance checks
     */
    initializeComplianceChecks() {
        const complianceFrameworks = [
            {
                id: 'owasp_asvs',
                name: 'OWASP Application Security Verification Standard',
                version: '4.0.3',
                categories: ['authentication', 'session_management', 'access_control', 'validation', 'cryptography'],
                checkCount: 286,
                applicableTargets: ['web_application', 'api_endpoints']
            },
            {
                id: 'nist_cybersecurity',
                name: 'NIST Cybersecurity Framework',
                version: '1.1',
                categories: ['identify', 'protect', 'detect', 'respond', 'recover'],
                checkCount: 108,
                applicableTargets: ['infrastructure', 'cloud_resources']
            },
            {
                id: 'iso_27001',
                name: 'ISO/IEC 27001',
                version: '2013',
                categories: ['information_security_policies', 'risk_management', 'asset_management', 'access_control'],
                checkCount: 114,
                applicableTargets: ['infrastructure', 'database_systems', 'cloud_resources']
            }
        ];

        complianceFrameworks.forEach(framework => {
            this.complianceChecks.set(framework.id, {
                ...framework,
                createdAt: Date.now(),
                lastAssessment: null,
                complianceScore: null
            });
        });

        console.log(`üîç Initialized ${complianceFrameworks.length} compliance frameworks`);
    }

    /**
     * Start periodic operations
     */
    startPeriodicOperations() {
        // Automated vulnerability scanning
        if (this.configuration.scanning.enableAutomatedScanning) {
            setInterval(() => {
                this.performAutomatedScanning();
            }, this.configuration.scanning.scanInterval);
        }

        // Continuous scanning
        if (this.configuration.scanning.enableContinuousScanning) {
            setInterval(() => {
                this.processScanQueue();
            }, 300000); // Every 5 minutes
        }

        // Remediation task monitoring
        setInterval(() => {
            this.monitorRemediationTasks();
        }, 3600000); // Every hour

        // CVE database updates
        if (this.configuration.integration.enableCVEIntegration) {
            setInterval(() => {
                this.updateCVEDatabase();
            }, 24 * 3600000); // Daily
        }
    }

    /**
     * Start vulnerability scan
     * @param {string} targetId - Target ID to scan
     * @param {Object} options - Scan options
     * @returns {Object} Scan initiation result
     */
    async startVulnerabilityScan(targetId, options = {}) {
        const scanId = `scan_${++this.scanCounter}_${Date.now()}`;
        
        try {
            const target = this.scanTargets.get(targetId);
            if (!target) {
                throw new Error('Scan target not found');
            }

            const policyId = options.policyId || this.getDefaultPolicy(target.type);
            const policy = this.scanPolicies.get(policyId);
            if (!policy) {
                throw new Error('Scan policy not found');
            }

            const scan = {
                id: scanId,
                targetId,
                policyId,
                status: 'running',
                startedAt: Date.now(),
                completedAt: null,
                progress: 0,
                configuration: {
                    scanType: options.scanType || 'comprehensive',
                    depth: options.depth || policy.depth,
                    timeout: options.timeout || this.configuration.scanning.scanTimeout,
                    enableExploitValidation: options.enableExploitValidation !== false,
                    aggressiveScanning: options.aggressiveScanning === true
                },
                results: {
                    vulnerabilitiesFound: 0,
                    criticalVulnerabilities: 0,
                    highVulnerabilities: 0,
                    mediumVulnerabilities: 0,
                    lowVulnerabilities: 0,
                    falsePositives: 0,
                    exploitsValidated: 0
                },
                vulnerabilities: [],
                metadata: {
                    initiatedBy: options.initiatedBy || 'system',
                    scanReason: options.scanReason || 'scheduled_scan',
                    estimatedDuration: policy.estimated_duration,
                    scanningEngine: 'MuseNest Security Scanner v1.0'
                }
            };

            // Store active scan
            this.activeScans.set(scanId, scan);

            // Update target scan statistics
            target.scanCount++;
            target.lastScan = Date.now();

            // Start scanning process
            await this.executeScan(scan, target, policy);

            await this.logVulnerabilityEvent('scan_started', {
                scanId,
                targetId,
                policyId,
                scanType: scan.configuration.scanType
            });

            return {
                success: true,
                scanId,
                targetName: target.name,
                policyName: policy.name,
                estimatedDuration: policy.estimated_duration,
                estimatedDurationMinutes: Math.round(policy.estimated_duration / 60000),
                status: scan.status,
                progressEndpoint: `/api/vulnerability-assessment/scans/${scanId}/progress`
            };

        } catch (error) {
            console.error('‚ùå Error starting vulnerability scan:', error.message);
            
            await this.logVulnerabilityEvent('scan_start_failed', {
                scanId,
                targetId,
                error: error.message
            });

            return {
                success: false,
                error: 'scan_start_failed',
                message: error.message
            };
        }
    }

    /**
     * Execute penetration test
     * @param {string} targetId - Target ID for penetration testing
     * @param {Object} options - Penetration testing options
     * @returns {Object} Penetration test result
     */
    async executePenetrationTest(targetId, options = {}) {
        const testId = `pentest_${++this.pentestCounter}_${Date.now()}`;
        
        try {
            const target = this.scanTargets.get(targetId);
            if (!target) {
                throw new Error('Target not found for penetration testing');
            }

            const penetrationTest = {
                id: testId,
                targetId,
                testType: options.testType || 'black_box',
                scope: options.scope || 'limited',
                methodology: options.methodology || 'owasp_testing_guide',
                status: 'running',
                startedAt: Date.now(),
                completedAt: null,
                tester: options.tester || 'automated_system',
                phases: {
                    reconnaissance: { status: 'pending', findings: [] },
                    scanning: { status: 'pending', findings: [] },
                    enumeration: { status: 'pending', findings: [] },
                    exploitation: { status: 'pending', findings: [] },
                    postExploitation: { status: 'pending', findings: [] },
                    reporting: { status: 'pending', findings: [] }
                },
                findings: [],
                exploitsUsed: [],
                compromisedSystems: [],
                dataAccessed: [],
                recommendations: [],
                riskRating: 'unknown',
                executiveSummary: '',
                configuration: {
                    enableSocialEngineering: options.enableSocialEngineering === true,
                    enablePhysicalSecurity: options.enablePhysicalSecurity === true,
                    maxExploitDepth: options.maxExploitDepth || 3,
                    testDuration: options.testDuration || 8 * 3600000, // 8 hours
                    safetyMode: options.safetyMode !== false
                }
            };

            // Store penetration test
            this.penetrationTests.set(testId, penetrationTest);

            // Execute penetration test phases
            await this.executePentestPhases(penetrationTest, target);

            await this.logVulnerabilityEvent('penetration_test_started', {
                testId,
                targetId,
                testType: penetrationTest.testType,
                methodology: penetrationTest.methodology
            });

            return {
                success: true,
                testId,
                targetName: target.name,
                testType: penetrationTest.testType,
                methodology: penetrationTest.methodology,
                estimatedDuration: penetrationTest.configuration.testDuration,
                estimatedDurationHours: Math.round(penetrationTest.configuration.testDuration / 3600000),
                status: penetrationTest.status,
                progressEndpoint: `/api/vulnerability-assessment/penetration-tests/${testId}/progress`
            };

        } catch (error) {
            console.error('‚ùå Error executing penetration test:', error.message);
            
            await this.logVulnerabilityEvent('penetration_test_failed', {
                testId,
                targetId,
                error: error.message
            });

            return {
                success: false,
                error: 'penetration_test_failed',
                message: error.message
            };
        }
    }

    /**
     * Create remediation task for vulnerability
     * @param {string} vulnerabilityId - Vulnerability ID
     * @param {Object} options - Remediation options
     * @returns {Object} Remediation task result
     */
    async createRemediationTask(vulnerabilityId, options = {}) {
        const taskId = `remediation_${++this.remediationCounter}_${Date.now()}`;
        
        try {
            const vulnerability = this.vulnerabilities.get(vulnerabilityId);
            if (!vulnerability) {
                throw new Error('Vulnerability not found');
            }

            const remediationTask = {
                id: taskId,
                vulnerabilityId,
                title: `Remediate ${vulnerability.name}`,
                description: vulnerability.remediation.description,
                priority: this.calculateRemediationPriority(vulnerability),
                status: 'open',
                assignedTo: options.assignedTo || null,
                createdAt: Date.now(),
                dueDate: Date.now() + (options.dueDate || this.configuration.vulnerability.remediationTimeout),
                startedAt: null,
                completedAt: null,
                estimatedEffort: options.estimatedEffort || vulnerability.remediation.effort,
                remediationType: vulnerability.remediation.type,
                steps: vulnerability.remediation.steps || [],
                verification: {
                    required: true,
                    method: 'scan_validation',
                    completed: false,
                    results: null
                },
                rollback: {
                    planRequired: this.configuration.remediation.rollbackCapability,
                    planCreated: false,
                    rollbackScript: null
                },
                approval: {
                    required: vulnerability.severity === 'critical',
                    approved: false,
                    approvedBy: null,
                    approvedAt: null
                },
                progress: {
                    percentComplete: 0,
                    currentStep: 0,
                    totalSteps: vulnerability.remediation.steps?.length || 1,
                    blockers: [],
                    notes: []
                }
            };

            // Store remediation task
            this.remediationTasks.set(taskId, remediationTask);

            // Create incident if critical vulnerability
            if (vulnerability.severity === 'critical' && this.incidentService) {
                await this.createVulnerabilityIncident(vulnerability, remediationTask);
            }

            await this.logVulnerabilityEvent('remediation_task_created', {
                taskId,
                vulnerabilityId,
                priority: remediationTask.priority,
                dueDate: remediationTask.dueDate
            });

            return {
                success: true,
                taskId,
                vulnerabilityName: vulnerability.name,
                priority: remediationTask.priority,
                dueDate: new Date(remediationTask.dueDate).toISOString(),
                estimatedEffort: remediationTask.estimatedEffort,
                remediationType: remediationTask.remediationType,
                approvalRequired: remediationTask.approval.required,
                rollbackPlanRequired: remediationTask.rollback.planRequired
            };

        } catch (error) {
            console.error('‚ùå Error creating remediation task:', error.message);
            
            await this.logVulnerabilityEvent('remediation_task_creation_failed', {
                taskId,
                vulnerabilityId,
                error: error.message
            });

            return {
                success: false,
                error: 'remediation_task_creation_failed',
                message: error.message
            };
        }
    }

    /**
     * Generate vulnerability assessment report
     * @param {Object} options - Report options
     * @returns {Object} Report generation result
     */
    async generateAssessmentReport(options = {}) {
        const reportId = `report_${++this.reportCounter}_${Date.now()}`;
        
        try {
            const timeRange = options.timeRange || 30 * 24 * 3600000; // 30 days
            const startDate = Date.now() - timeRange;
            const endDate = Date.now();

            // Collect data for report
            const scans = Array.from(this.activeScans.values())
                .filter(scan => scan.startedAt >= startDate);
            
            const vulnerabilities = Array.from(this.vulnerabilities.values())
                .filter(vuln => vuln.discoveredAt >= startDate);

            const penetrationTests = Array.from(this.penetrationTests.values())
                .filter(test => test.startedAt >= startDate);

            const remediationTasks = Array.from(this.remediationTasks.values())
                .filter(task => task.createdAt >= startDate);

            const report = {
                id: reportId,
                title: options.title || 'Vulnerability Assessment Report',
                generatedAt: Date.now(),
                generatedBy: options.generatedBy || 'system',
                reportPeriod: {
                    startDate: new Date(startDate).toISOString(),
                    endDate: new Date(endDate).toISOString(),
                    duration: timeRange
                },
                executiveSummary: {
                    totalScans: scans.length,
                    totalVulnerabilities: vulnerabilities.length,
                    criticalVulnerabilities: vulnerabilities.filter(v => v.severity === 'critical').length,
                    highVulnerabilities: vulnerabilities.filter(v => v.severity === 'high').length,
                    mediumVulnerabilities: vulnerabilities.filter(v => v.severity === 'medium').length,
                    lowVulnerabilities: vulnerabilities.filter(v => v.severity === 'low').length,
                    remediatedVulnerabilities: vulnerabilities.filter(v => v.status === 'resolved').length,
                    penetrationTestsExecuted: penetrationTests.length,
                    overallRiskScore: this.calculateOverallRiskScore(vulnerabilities),
                    trendAnalysis: this.performTrendAnalysis(vulnerabilities, timeRange)
                },
                scanningResults: {
                    scansPerformed: scans.length,
                    targetsScanned: new Set(scans.map(s => s.targetId)).size,
                    avgScanDuration: scans.length > 0 ? 
                        Math.round(scans.reduce((sum, s) => sum + (s.completedAt - s.startedAt), 0) / scans.length / 60000) : 0,
                    scanSuccessRate: scans.length > 0 ? 
                        Math.round(scans.filter(s => s.status === 'completed').length / scans.length * 100) : 100,
                    falsePositiveRate: vulnerabilities.length > 0 ? 
                        Math.round(vulnerabilities.filter(v => v.falsePositive).length / vulnerabilities.length * 100) : 0
                },
                vulnerabilityAnalysis: {
                    topVulnerabilityTypes: this.getTopVulnerabilityTypes(vulnerabilities),
                    affectedTargets: this.getAffectedTargets(vulnerabilities),
                    severityDistribution: this.getSeverityDistribution(vulnerabilities),
                    ageAnalysis: this.getVulnerabilityAgeAnalysis(vulnerabilities),
                    cvssScoreAnalysis: this.getCVSSScoreAnalysis(vulnerabilities)
                },
                penetrationTestingResults: penetrationTests.length > 0 ? {
                    testsExecuted: penetrationTests.length,
                    avgTestDuration: Math.round(penetrationTests.reduce((sum, t) => 
                        sum + (t.completedAt - t.startedAt), 0) / penetrationTests.length / 3600000),
                    systemsCompromised: penetrationTests.reduce((sum, t) => sum + t.compromisedSystems.length, 0),
                    exploitsUsed: penetrationTests.reduce((sum, t) => sum + t.exploitsUsed.length, 0),
                    dataAccessed: penetrationTests.reduce((sum, t) => sum + t.dataAccessed.length, 0)
                } : null,
                remediationStatus: {
                    tasksCreated: remediationTasks.length,
                    tasksCompleted: remediationTasks.filter(t => t.status === 'completed').length,
                    tasksOverdue: remediationTasks.filter(t => 
                        Date.now() > t.dueDate && t.status !== 'completed').length,
                    avgRemediationTime: this.calculateAverageRemediationTime(remediationTasks),
                    remediationSuccessRate: remediationTasks.length > 0 ? 
                        Math.round(remediationTasks.filter(t => t.status === 'completed').length / remediationTasks.length * 100) : 100
                },
                complianceStatus: await this.getComplianceStatus(),
                recommendations: this.generateRecommendations(vulnerabilities, penetrationTests, remediationTasks),
                actionPlan: this.generateActionPlan(vulnerabilities, remediationTasks),
                metadata: {
                    reportFormat: options.format || 'json',
                    confidentialityLevel: 'confidential',
                    audience: options.audience || 'security_team',
                    nextReportDue: new Date(Date.now() + 7 * 24 * 3600000).toISOString()
                }
            };

            // Store report
            this.reports.set(reportId, report);

            await this.logVulnerabilityEvent('assessment_report_generated', {
                reportId,
                vulnerabilitiesAnalyzed: vulnerabilities.length,
                period: timeRange
            });

            return {
                success: true,
                reportId,
                generatedAt: new Date(report.generatedAt).toISOString(),
                vulnerabilitiesAnalyzed: vulnerabilities.length,
                overallRiskScore: report.executiveSummary.overallRiskScore,
                criticalVulnerabilities: report.executiveSummary.criticalVulnerabilities,
                reportUrl: `/api/vulnerability-assessment/reports/${reportId}`,
                downloadUrl: `/api/vulnerability-assessment/reports/${reportId}/download`
            };

        } catch (error) {
            console.error('‚ùå Error generating assessment report:', error.message);
            
            await this.logVulnerabilityEvent('report_generation_failed', {
                reportId,
                error: error.message
            });

            return {
                success: false,
                error: 'report_generation_failed',
                message: error.message
            };
        }
    }

    /**
     * Get vulnerability assessment status
     * @returns {Object} Status information
     */
    getVulnerabilityAssessmentStatus() {
        const activeScansCount = Array.from(this.activeScans.values()).filter(s => s.status === 'running').length;
        const totalVulnerabilities = this.vulnerabilities.size;
        const criticalVulnerabilities = Array.from(this.vulnerabilities.values()).filter(v => v.severity === 'critical').length;
        const openRemediationTasks = Array.from(this.remediationTasks.values()).filter(t => t.status === 'open').length;

        return {
            isActive: this.isActive,
            configuration: this.configuration,
            metrics: {
                scanTargets: this.scanTargets.size,
                scanPolicies: this.scanPolicies.size,
                activeScans: activeScansCount,
                totalScans: this.activeScans.size,
                vulnerabilities: totalVulnerabilities,
                criticalVulnerabilities,
                highVulnerabilities: Array.from(this.vulnerabilities.values()).filter(v => v.severity === 'high').length,
                mediumVulnerabilities: Array.from(this.vulnerabilities.values()).filter(v => v.severity === 'medium').length,
                lowVulnerabilities: Array.from(this.vulnerabilities.values()).filter(v => v.severity === 'low').length,
                penetrationTests: this.penetrationTests.size,
                activePenetrationTests: Array.from(this.penetrationTests.values()).filter(t => t.status === 'running').length,
                remediationTasks: this.remediationTasks.size,
                openRemediationTasks,
                overDueRemediationTasks: Array.from(this.remediationTasks.values())
                    .filter(t => Date.now() > t.dueDate && t.status !== 'completed').length,
                reports: this.reports.size,
                exploitDatabase: this.exploitDatabase.size,
                complianceChecks: this.complianceChecks.size
            },
            vulnerabilityEvents: (this.vulnerabilityEvents || []).length,
            lastActivity: Date.now()
        };
    }

    // Helper methods and counters
    scanCounter = 0;
    pentestCounter = 0;
    remediationCounter = 0;
    reportCounter = 0;

    async executeScan(scan, target, policy) {
        // Simulate scanning process
        for (let i = 0; i <= 100; i += 10) {
            scan.progress = i;
            if (i === 50) {
                // Simulate finding vulnerabilities
                await this.simulateVulnerabilityDiscovery(scan, target);
            }
            await new Promise(resolve => setTimeout(resolve, Math.random() * 2000 + 1000));
        }
        
        scan.status = 'completed';
        scan.completedAt = Date.now();
        
        await this.logVulnerabilityEvent('scan_completed', {
            scanId: scan.id,
            vulnerabilitiesFound: scan.results.vulnerabilitiesFound,
            duration: scan.completedAt - scan.startedAt
        });
    }

    async simulateVulnerabilityDiscovery(scan, target) {
        const vulnerabilityCount = Math.floor(Math.random() * 8) + 2; // 2-9 vulnerabilities
        
        for (let i = 0; i < vulnerabilityCount; i++) {
            const vulnerabilityId = `vuln_${++this.vulnCounter}_${Date.now()}`;
            const severity = this.getRandomSeverity();
            
            const vulnerability = {
                id: vulnerabilityId,
                scanId: scan.id,
                targetId: target.id,
                name: this.getRandomVulnerabilityName(),
                description: 'Simulated vulnerability discovered during automated scan',
                severity,
                cvssScore: this.getCVSSScore(severity),
                category: this.getRandomCategory(),
                status: 'open',
                discoveredAt: Date.now(),
                lastSeen: Date.now(),
                falsePositive: false,
                exploitable: Math.random() > 0.7,
                remediation: {
                    type: 'patch',
                    description: 'Apply security patch or configuration change',
                    effort: this.getRemediationEffort(severity),
                    steps: this.getRemediationSteps()
                },
                references: [`CVE-2023-${Math.floor(Math.random() * 90000) + 10000}`],
                impact: {
                    confidentiality: severity === 'critical' ? 'high' : 'medium',
                    integrity: severity === 'critical' ? 'high' : 'low',
                    availability: Math.random() > 0.5 ? 'medium' : 'none'
                }
            };
            
            this.vulnerabilities.set(vulnerabilityId, vulnerability);
            scan.vulnerabilities.push(vulnerabilityId);
            scan.results.vulnerabilitiesFound++;
            scan.results[`${severity}Vulnerabilities`]++;
        }
    }

    async executePentestPhases(test, target) {
        const phases = ['reconnaissance', 'scanning', 'enumeration', 'exploitation', 'postExploitation', 'reporting'];
        
        for (const phase of phases) {
            test.phases[phase].status = 'running';
            
            // Simulate phase execution
            await new Promise(resolve => setTimeout(resolve, Math.random() * 30000 + 10000)); // 10-40 seconds
            
            // Generate findings for phase
            const findings = await this.generatePhaseFindings(phase, target);
            test.phases[phase].findings = findings;
            test.phases[phase].status = 'completed';
            
            test.findings.push(...findings);
        }
        
        test.status = 'completed';
        test.completedAt = Date.now();
        test.riskRating = this.calculatePentestRiskRating(test.findings);
        test.executiveSummary = this.generateExecutiveSummary(test);
    }

    async generatePhaseFindings(phase, target) {
        const phaseFindings = {
            reconnaissance: ['Domain enumeration completed', 'Social media footprinting performed'],
            scanning: ['Open ports identified', 'Services fingerprinted'],
            enumeration: ['User accounts enumerated', 'System information gathered'],
            exploitation: ['Authentication bypass achieved', 'Code execution obtained'],
            postExploitation: ['Privilege escalation successful', 'Lateral movement performed'],
            reporting: ['Evidence collected', 'Impact assessment completed']
        };
        
        return phaseFindings[phase] || [];
    }

    // Utility methods
    getDefaultPolicy(targetType) {
        const policyMap = {
            web_app: 'owasp_top_10',
            infrastructure: 'network_security',
            cloud: 'cloud_security_aws',
            database: 'owasp_top_10'
        };
        
        return policyMap[targetType] || 'owasp_top_10';
    }

    getRandomSeverity() {
        const severities = ['critical', 'high', 'medium', 'low'];
        const weights = [0.1, 0.2, 0.4, 0.3]; // Distribution weights
        const random = Math.random();
        let cumulative = 0;
        
        for (let i = 0; i < severities.length; i++) {
            cumulative += weights[i];
            if (random <= cumulative) {
                return severities[i];
            }
        }
        return 'low';
    }

    getCVSSScore(severity) {
        const ranges = {
            critical: [9.0, 10.0],
            high: [7.0, 8.9],
            medium: [4.0, 6.9],
            low: [0.1, 3.9]
        };
        
        const range = ranges[severity];
        return Math.round((Math.random() * (range[1] - range[0]) + range[0]) * 10) / 10;
    }

    getRandomVulnerabilityName() {
        const names = [
            'SQL Injection in Login Form',
            'Cross-Site Scripting (XSS) in Search',
            'Insecure Direct Object Reference',
            'Broken Authentication',
            'Security Misconfiguration',
            'Sensitive Data Exposure',
            'Insufficient Logging & Monitoring',
            'Using Components with Known Vulnerabilities',
            'Unvalidated Redirects and Forwards',
            'Cross-Site Request Forgery (CSRF)'
        ];
        
        return names[Math.floor(Math.random() * names.length)];
    }

    getRandomCategory() {
        const categories = [
            'injection', 'broken_authentication', 'sensitive_data_exposure',
            'xml_external_entities', 'broken_access_control', 'security_misconfiguration',
            'xss', 'insecure_deserialization', 'vulnerable_components', 'insufficient_logging'
        ];
        
        return categories[Math.floor(Math.random() * categories.length)];
    }

    getRemediationEffort(severity) {
        const efforts = {
            critical: 'high',
            high: 'medium',
            medium: 'medium',
            low: 'low'
        };
        
        return efforts[severity] || 'medium';
    }

    getRemediationSteps() {
        return [
            'Analyze vulnerability details and impact',
            'Identify affected systems and components',
            'Develop remediation plan',
            'Test remediation in staging environment',
            'Apply fix to production systems',
            'Verify remediation effectiveness',
            'Update documentation and monitoring'
        ];
    }

    calculateRemediationPriority(vulnerability) {
        const severityScore = { critical: 4, high: 3, medium: 2, low: 1 }[vulnerability.severity] || 1;
        const exploitableScore = vulnerability.exploitable ? 2 : 1;
        const totalScore = severityScore * exploitableScore;
        
        if (totalScore >= 6) return 'critical';
        if (totalScore >= 4) return 'high';
        if (totalScore >= 2) return 'medium';
        return 'low';
    }

    calculateOverallRiskScore(vulnerabilities) {
        if (vulnerabilities.length === 0) return 0;
        
        const totalScore = vulnerabilities.reduce((sum, vuln) => {
            return sum + vuln.cvssScore;
        }, 0);
        
        return Math.round((totalScore / vulnerabilities.length) * 10) / 10;
    }

    // Periodic operation methods
    async performAutomatedScanning() {
        console.log('üîç Performing automated vulnerability scanning');
        
        for (const [targetId, target] of this.scanTargets.entries()) {
            if (target.active && (!target.lastScan || 
                Date.now() - target.lastScan > target.scanFrequency)) {
                this.scanQueue.push({ targetId, priority: target.priority });
            }
        }
    }

    async processScanQueue() {
        if (this.scanQueue.length === 0) return;
        
        const concurrentLimit = this.configuration.scanning.maxConcurrentScans;
        const runningScans = Array.from(this.activeScans.values()).filter(s => s.status === 'running').length;
        
        if (runningScans >= concurrentLimit) return;
        
        const scansToStart = Math.min(this.scanQueue.length, concurrentLimit - runningScans);
        
        for (let i = 0; i < scansToStart; i++) {
            const scanRequest = this.scanQueue.shift();
            await this.startVulnerabilityScan(scanRequest.targetId, { 
                initiatedBy: 'automated_scheduler',
                scanReason: 'scheduled_scan' 
            });
        }
    }

    async monitorRemediationTasks() {
        const now = Date.now();
        
        for (const [taskId, task] of this.remediationTasks.entries()) {
            if (task.status === 'open' && now > task.dueDate) {
                await this.logVulnerabilityEvent('remediation_task_overdue', {
                    taskId,
                    vulnerabilityId: task.vulnerabilityId,
                    daysPastDue: Math.round((now - task.dueDate) / (24 * 3600000))
                });
            }
        }
    }

    async updateCVEDatabase() {
        console.log('üîç Updating CVE database');
        // In production, this would fetch latest CVE data
    }

    async logVulnerabilityEvent(eventType, eventData) {
        const event = {
            id: `vuln_event_${++this.eventCounter}_${Date.now()}`,
            timestamp: Date.now(),
            eventType: `vulnerability_assessment:${eventType}`,
            data: eventData,
            severity: this.getEventSeverity(eventType)
        };

        if (!this.vulnerabilityEvents) this.vulnerabilityEvents = [];
        this.vulnerabilityEvents.push(event);
        if (this.vulnerabilityEvents.length > 10000) {
            this.vulnerabilityEvents = this.vulnerabilityEvents.slice(-5000);
        }

        this.emit('vulnerabilityEvent', event);
    }

    getEventSeverity(eventType) {
        const severityMap = {
            'scan_started': 'info',
            'scan_completed': 'info',
            'penetration_test_started': 'info',
            'remediation_task_created': 'info',
            'assessment_report_generated': 'info',
            'scan_start_failed': 'error',
            'penetration_test_failed': 'error',
            'remediation_task_overdue': 'warning'
        };

        return severityMap[eventType] || 'info';
    }

    // Report generation helper methods
    performTrendAnalysis(vulnerabilities, timeRange) {
        // Simplified trend analysis
        const halfwayPoint = Date.now() - (timeRange / 2);
        const firstHalf = vulnerabilities.filter(v => v.discoveredAt < halfwayPoint).length;
        const secondHalf = vulnerabilities.filter(v => v.discoveredAt >= halfwayPoint).length;
        
        if (secondHalf > firstHalf * 1.2) return 'increasing';
        if (secondHalf < firstHalf * 0.8) return 'decreasing';
        return 'stable';
    }

    getTopVulnerabilityTypes(vulnerabilities) {
        const typeCounts = vulnerabilities.reduce((acc, vuln) => {
            acc[vuln.category] = (acc[vuln.category] || 0) + 1;
            return acc;
        }, {});
        
        return Object.entries(typeCounts)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 5)
            .map(([type, count]) => ({ type, count }));
    }

    getAffectedTargets(vulnerabilities) {
        const targetCounts = vulnerabilities.reduce((acc, vuln) => {
            acc[vuln.targetId] = (acc[vuln.targetId] || 0) + 1;
            return acc;
        }, {});
        
        return Object.entries(targetCounts).map(([targetId, count]) => {
            const target = this.scanTargets.get(targetId);
            return { 
                targetId, 
                targetName: target?.name || 'Unknown',
                vulnerabilityCount: count 
            };
        });
    }

    getSeverityDistribution(vulnerabilities) {
        return vulnerabilities.reduce((acc, vuln) => {
            acc[vuln.severity] = (acc[vuln.severity] || 0) + 1;
            return acc;
        }, {});
    }

    getVulnerabilityAgeAnalysis(vulnerabilities) {
        const now = Date.now();
        const ages = vulnerabilities.map(vuln => now - vuln.discoveredAt);
        
        return {
            avgAge: ages.length > 0 ? Math.round(ages.reduce((a, b) => a + b, 0) / ages.length / (24 * 3600000)) : 0,
            oldestAge: ages.length > 0 ? Math.round(Math.max(...ages) / (24 * 3600000)) : 0,
            newestAge: ages.length > 0 ? Math.round(Math.min(...ages) / (24 * 3600000)) : 0
        };
    }

    getCVSSScoreAnalysis(vulnerabilities) {
        const scores = vulnerabilities.map(vuln => vuln.cvssScore);
        
        return {
            avgScore: scores.length > 0 ? Math.round(scores.reduce((a, b) => a + b, 0) / scores.length * 10) / 10 : 0,
            highestScore: scores.length > 0 ? Math.max(...scores) : 0,
            lowestScore: scores.length > 0 ? Math.min(...scores) : 0
        };
    }

    calculateAverageRemediationTime(tasks) {
        const completed = tasks.filter(t => t.completedAt && t.startedAt);
        if (completed.length === 0) return 0;
        
        const totalTime = completed.reduce((sum, task) => sum + (task.completedAt - task.startedAt), 0);
        return Math.round(totalTime / completed.length / (24 * 3600000)); // days
    }

    async getComplianceStatus() {
        const frameworks = Array.from(this.complianceChecks.values());
        
        return frameworks.map(framework => ({
            id: framework.id,
            name: framework.name,
            version: framework.version,
            complianceScore: framework.complianceScore || Math.floor(Math.random() * 30) + 70, // 70-99%
            lastAssessment: framework.lastAssessment ? new Date(framework.lastAssessment).toISOString() : null,
            checkCount: framework.checkCount
        }));
    }

    generateRecommendations(vulnerabilities, penetrationTests, remediationTasks) {
        const recommendations = [];
        
        if (vulnerabilities.filter(v => v.severity === 'critical').length > 0) {
            recommendations.push('Immediately address all critical vulnerabilities');
        }
        
        if (remediationTasks.filter(t => Date.now() > t.dueDate && t.status !== 'completed').length > 5) {
            recommendations.push('Improve remediation task management and tracking');
        }
        
        if (penetrationTests.some(t => t.compromisedSystems.length > 0)) {
            recommendations.push('Strengthen security controls to prevent system compromise');
        }
        
        recommendations.push('Implement continuous security monitoring');
        recommendations.push('Regular security awareness training for staff');
        
        return recommendations;
    }

    generateActionPlan(vulnerabilities, remediationTasks) {
        const criticalTasks = remediationTasks.filter(t => t.priority === 'critical' && t.status === 'open');
        const overdueTasks = remediationTasks.filter(t => Date.now() > t.dueDate && t.status !== 'completed');
        
        return {
            immediate: [
                `Address ${criticalTasks.length} critical vulnerabilities`,
                `Complete ${overdueTasks.length} overdue remediation tasks`
            ],
            shortTerm: [
                'Implement automated vulnerability scanning',
                'Establish vulnerability disclosure program'
            ],
            longTerm: [
                'Develop comprehensive security program',
                'Implement security metrics and KPIs'
            ]
        };
    }

    calculatePentestRiskRating(findings) {
        if (findings.some(f => f.includes('Code execution') || f.includes('system compromise'))) {
            return 'critical';
        }
        if (findings.some(f => f.includes('Privilege escalation') || f.includes('bypass'))) {
            return 'high';
        }
        if (findings.length > 5) {
            return 'medium';
        }
        return 'low';
    }

    generateExecutiveSummary(test) {
        return `Penetration test completed for ${test.targetId}. ` +
               `${test.findings.length} findings identified with overall risk rating of ${test.riskRating}. ` +
               `${test.exploitsUsed.length} exploits were successfully executed during the assessment.`;
    }

    async createVulnerabilityIncident(vulnerability, remediationTask) {
        if (!this.incidentService) return;
        
        const incidentData = {
            title: `Critical Vulnerability: ${vulnerability.name}`,
            description: `Critical security vulnerability discovered requiring immediate attention`,
            type: 'vulnerability_incident',
            severity: 'critical',
            source: 'vulnerability_scanner',
            affectedSystems: [vulnerability.targetId],
            indicators: [vulnerability.category, 'high_cvss_score'],
            impact: vulnerability.impact
        };
        
        await this.incidentService.createIncident(incidentData, {
            createdBy: 'vulnerability_assessment_system'
        });
    }

    vulnCounter = 0;
    eventCounter = 0;
}

module.exports = VulnerabilityAssessmentService;