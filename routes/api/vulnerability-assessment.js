/**
 * Penetration Testing and Vulnerability Assessment API Routes
 * Part of Phase F.6: Add penetration testing and vulnerability assessment
 * Provides API endpoints for vulnerability scanning, penetration testing, and security assessments
 */

const express = require('express');
const router = express.Router();
const VulnerabilityAssessmentService = require('../../src/services/VulnerabilityAssessmentService');
const SecurityMonitoringService = require('../../src/services/SecurityMonitoringService');
const IncidentResponseService = require('../../src/services/IncidentResponseService');
const ComplianceFrameworkService = require('../../src/services/ComplianceFrameworkService');
const AdvancedAnalyticsService = require('../../src/services/AdvancedAnalyticsService');

// Initialize services
let vulnerabilityService = null;
let securityService = null;
let incidentService = null;
let complianceService = null;
let analyticsService = null;

// Middleware to initialize vulnerability assessment service
router.use((req, res, next) => {
    if (!vulnerabilityService) {
        // Initialize dependencies first
        if (!analyticsService) {
            analyticsService = new AdvancedAnalyticsService(req.db, {
                collection: {
                    realTimeInterval: 30000,
                    aggregationInterval: 300000
                }
            });
        }

        if (!securityService) {
            securityService = new SecurityMonitoringService(req.db, analyticsService, {
                monitoring: { enableRealTime: true }
            });
        }

        if (!complianceService) {
            const complianceConfig = {
                compliance: {
                    enableContinuousMonitoring: true,
                    complianceCheckInterval: 3600000,
                    auditRetentionYears: 7
                }
            };
            complianceService = new ComplianceFrameworkService(req.db, securityService, complianceConfig);
        }

        if (!incidentService) {
            const incidentConfig = {
                response: {
                    enableAutoResponse: true,
                    responseTimeThreshold: 300000
                }
            };
            incidentService = new IncidentResponseService(req.db, securityService, complianceService, incidentConfig);
        }

        const config = {
            scanning: {
                enableAutomatedScanning: process.env.VULN_AUTO_SCANNING !== 'false',
                scanInterval: parseInt(process.env.VULN_SCAN_INTERVAL) || 7 * 24 * 3600000,
                enableContinuousScanning: process.env.VULN_CONTINUOUS_SCANNING !== 'false',
                maxConcurrentScans: parseInt(process.env.VULN_MAX_CONCURRENT_SCANS) || 5,
                scanTimeout: parseInt(process.env.VULN_SCAN_TIMEOUT) || 3600000,
                enableDeepScanning: process.env.VULN_DEEP_SCANNING !== 'false',
                enableComplianceScanning: process.env.VULN_COMPLIANCE_SCANNING !== 'false'
            },
            assessment: {
                enablePenetrationTesting: process.env.PENTEST_ENABLED !== 'false',
                testingFrequency: parseInt(process.env.PENTEST_FREQUENCY) || 30 * 24 * 3600000,
                testingDepth: process.env.PENTEST_DEPTH || 'standard',
                enableRedTeamExercises: process.env.REDTEAM_ENABLED !== 'false',
                enableSocialEngineering: process.env.SOCIAL_ENGINEERING_TESTS !== 'false',
                enablePhysicalSecurity: process.env.PHYSICAL_SECURITY_TESTS !== 'false'
            },
            vulnerability: {
                severityThresholds: {
                    critical: parseFloat(process.env.VULN_CRITICAL_THRESHOLD) || 9.0,
                    high: parseFloat(process.env.VULN_HIGH_THRESHOLD) || 7.0,
                    medium: parseFloat(process.env.VULN_MEDIUM_THRESHOLD) || 4.0,
                    low: 0.0
                },
                autoRemediation: process.env.VULN_AUTO_REMEDIATION !== 'false',
                remediationTimeout: parseInt(process.env.VULN_REMEDIATION_TIMEOUT) || 30 * 24 * 3600000,
                falsePositiveFiltering: process.env.VULN_FALSE_POSITIVE_FILTERING !== 'false',
                contextualScoring: process.env.VULN_CONTEXTUAL_SCORING !== 'false'
            },
            reporting: {
                enableAutomatedReporting: process.env.VULN_AUTO_REPORTING !== 'false',
                reportFormats: (process.env.VULN_REPORT_FORMATS || 'json,pdf,html,xml').split(','),
                executiveReporting: process.env.VULN_EXECUTIVE_REPORTING !== 'false',
                complianceReporting: process.env.VULN_COMPLIANCE_REPORTING !== 'false',
                trendAnalysis: process.env.VULN_TREND_ANALYSIS !== 'false',
                benchmarking: process.env.VULN_BENCHMARKING !== 'false'
            },
            integration: {
                enableCVEIntegration: process.env.CVE_INTEGRATION !== 'false',
                enableNVDIntegration: process.env.NVD_INTEGRATION !== 'false',
                enableOWASPIntegration: process.env.OWASP_INTEGRATION !== 'false',
                threatIntelligenceIntegration: process.env.THREAT_INTEL_INTEGRATION !== 'false',
                ticketSystemIntegration: process.env.TICKET_SYSTEM_INTEGRATION !== 'false'
            },
            remediation: {
                enableAutomatedRemediation: process.env.AUTO_REMEDIATION !== 'false',
                autoApplyPatches: process.env.AUTO_APPLY_PATCHES !== 'false',
                testPatchesFirst: process.env.TEST_PATCHES_FIRST !== 'false',
                rollbackCapability: process.env.ROLLBACK_CAPABILITY !== 'false',
                changeManagementIntegration: process.env.CHANGE_MGMT_INTEGRATION !== 'false'
            }
        };

        vulnerabilityService = new VulnerabilityAssessmentService(req.db, securityService, incidentService, config);
        console.log('🔍 VulnerabilityAssessmentService initialized for API routes');
    }
    next();
});

/**
 * POST /api/vulnerability-assessment/scans
 * Start a new vulnerability scan
 */
router.post('/scans', async (req, res) => {
    try {
        if (!vulnerabilityService) {
            return res.status(500).json({
                success: false,
                error: 'Vulnerability assessment service not initialized'
            });
        }

        const { targetId, policyId, scanType, depth, enableExploitValidation, aggressiveScanning } = req.body;
        
        if (!targetId) {
            return res.status(400).json({
                success: false,
                error: 'targetId is required'
            });
        }

        const options = {
            policyId,
            scanType: scanType || 'comprehensive',
            depth: depth || 'standard',
            enableExploitValidation: enableExploitValidation !== false,
            aggressiveScanning: aggressiveScanning === true,
            initiatedBy: req.user?.id || req.headers['x-user-id'] || 'api_user',
            scanReason: 'manual_scan'
        };

        console.log(`🔍 Starting vulnerability scan for target: ${targetId}`);
        
        const scanResult = await vulnerabilityService.startVulnerabilityScan(targetId, options);
        
        if (scanResult.success) {
            res.status(201).json({
                success: true,
                message: 'Vulnerability scan started successfully',
                scan: {
                    id: scanResult.scanId,
                    targetName: scanResult.targetName,
                    policyName: scanResult.policyName,
                    estimatedDuration: scanResult.estimatedDuration,
                    estimatedDurationMinutes: scanResult.estimatedDurationMinutes,
                    status: scanResult.status
                },
                monitoring: {
                    progressEndpoint: scanResult.progressEndpoint,
                    resultsEndpoint: `/api/vulnerability-assessment/scans/${scanResult.scanId}/results`,
                    stopEndpoint: `/api/vulnerability-assessment/scans/${scanResult.scanId}/stop`
                },
                scanConfiguration: {
                    scanType: options.scanType,
                    depth: options.depth,
                    exploitValidationEnabled: options.enableExploitValidation,
                    aggressiveScanning: options.aggressiveScanning
                },
                timestamp: new Date().toISOString()
            });
        } else {
            res.status(400).json({
                success: false,
                error: scanResult.error,
                message: scanResult.message
            });
        }

    } catch (error) {
        console.error('❌ Error starting vulnerability scan:', error.message);
        res.status(500).json({
            success: false,
            error: 'vulnerability_scan_service_error',
            message: 'Vulnerability scan service error'
        });
    }
});

/**
 * GET /api/vulnerability-assessment/scans
 * Get vulnerability scans with filtering and pagination
 */
router.get('/scans', (req, res) => {
    try {
        if (!vulnerabilityService) {
            return res.status(500).json({
                success: false,
                error: 'Vulnerability assessment service not initialized'
            });
        }

        const { status, targetId, policyId, limit = 50, page = 1 } = req.query;
        let scans = Array.from(vulnerabilityService.activeScans.values());

        // Apply filters
        if (status) {
            scans = scans.filter(s => s.status === status);
        }
        if (targetId) {
            scans = scans.filter(s => s.targetId === targetId);
        }
        if (policyId) {
            scans = scans.filter(s => s.policyId === policyId);
        }

        // Sort by start time (newest first)
        scans = scans.sort((a, b) => b.startedAt - a.startedAt);

        // Pagination
        const totalScans = scans.length;
        const startIndex = (parseInt(page) - 1) * parseInt(limit);
        const endIndex = startIndex + parseInt(limit);
        const paginatedScans = scans.slice(startIndex, endIndex);

        const formattedScans = paginatedScans.map(scan => {
            const target = vulnerabilityService.scanTargets.get(scan.targetId);
            const policy = vulnerabilityService.scanPolicies.get(scan.policyId);
            
            return {
                id: scan.id,
                targetId: scan.targetId,
                targetName: target?.name || 'Unknown Target',
                policyId: scan.policyId,
                policyName: policy?.name || 'Unknown Policy',
                status: scan.status,
                progress: scan.progress,
                startedAt: new Date(scan.startedAt).toISOString(),
                completedAt: scan.completedAt ? new Date(scan.completedAt).toISOString() : null,
                configuration: scan.configuration,
                results: {
                    vulnerabilitiesFound: scan.results.vulnerabilitiesFound,
                    criticalVulnerabilities: scan.results.criticalVulnerabilities,
                    highVulnerabilities: scan.results.highVulnerabilities,
                    mediumVulnerabilities: scan.results.mediumVulnerabilities,
                    lowVulnerabilities: scan.results.lowVulnerabilities,
                    exploitsValidated: scan.results.exploitsValidated,
                    falsePositives: scan.results.falsePositives
                },
                duration: scan.completedAt ? scan.completedAt - scan.startedAt : Date.now() - scan.startedAt,
                durationMinutes: scan.completedAt ? 
                    Math.round((scan.completedAt - scan.startedAt) / 60000) : 
                    Math.round((Date.now() - scan.startedAt) / 60000),
                initiatedBy: scan.metadata.initiatedBy,
                scanReason: scan.metadata.scanReason
            };
        });

        res.json({
            success: true,
            scans: formattedScans,
            pagination: {
                page: parseInt(page),
                limit: parseInt(limit),
                total: totalScans,
                totalPages: Math.ceil(totalScans / parseInt(limit)),
                hasNext: endIndex < totalScans,
                hasPrev: startIndex > 0
            },
            summary: {
                total: formattedScans.length,
                running: formattedScans.filter(s => s.status === 'running').length,
                completed: formattedScans.filter(s => s.status === 'completed').length,
                failed: formattedScans.filter(s => s.status === 'failed').length,
                totalVulnerabilitiesFound: formattedScans.reduce((sum, s) => sum + s.results.vulnerabilitiesFound, 0),
                avgScanDuration: formattedScans.filter(s => s.completedAt).length > 0 ? 
                    Math.round(formattedScans
                        .filter(s => s.completedAt)
                        .reduce((sum, s) => sum + s.durationMinutes, 0) / 
                        formattedScans.filter(s => s.completedAt).length) : 0
            }
        });

    } catch (error) {
        console.error('❌ Error getting vulnerability scans:', error.message);
        res.status(500).json({
            success: false,
            error: 'scans_retrieval_service_error',
            message: 'Failed to retrieve vulnerability scans'
        });
    }
});

/**
 * GET /api/vulnerability-assessment/scans/:scanId
 * Get detailed scan information and results
 */
router.get('/scans/:scanId', (req, res) => {
    try {
        if (!vulnerabilityService) {
            return res.status(500).json({
                success: false,
                error: 'Vulnerability assessment service not initialized'
            });
        }

        const { scanId } = req.params;
        const scan = vulnerabilityService.activeScans.get(scanId);

        if (!scan) {
            return res.status(404).json({
                success: false,
                error: 'scan_not_found',
                message: 'Vulnerability scan not found'
            });
        }

        const target = vulnerabilityService.scanTargets.get(scan.targetId);
        const policy = vulnerabilityService.scanPolicies.get(scan.policyId);

        // Get vulnerability details
        const vulnerabilityDetails = scan.vulnerabilities.map(vulnId => {
            const vulnerability = vulnerabilityService.vulnerabilities.get(vulnId);
            return vulnerability ? {
                id: vulnerability.id,
                name: vulnerability.name,
                description: vulnerability.description,
                severity: vulnerability.severity,
                cvssScore: vulnerability.cvssScore,
                category: vulnerability.category,
                status: vulnerability.status,
                exploitable: vulnerability.exploitable,
                remediation: {
                    type: vulnerability.remediation.type,
                    description: vulnerability.remediation.description,
                    effort: vulnerability.remediation.effort
                },
                impact: vulnerability.impact,
                references: vulnerability.references
            } : null;
        }).filter(v => v);

        const detailedScan = {
            id: scan.id,
            targetId: scan.targetId,
            targetName: target?.name || 'Unknown Target',
            targetType: target?.type || 'unknown',
            policyId: scan.policyId,
            policyName: policy?.name || 'Unknown Policy',
            status: scan.status,
            progress: scan.progress,
            startedAt: new Date(scan.startedAt).toISOString(),
            completedAt: scan.completedAt ? new Date(scan.completedAt).toISOString() : null,
            duration: scan.completedAt ? scan.completedAt - scan.startedAt : Date.now() - scan.startedAt,
            durationMinutes: scan.completedAt ? 
                Math.round((scan.completedAt - scan.startedAt) / 60000) : 
                Math.round((Date.now() - scan.startedAt) / 60000),
            configuration: {
                scanType: scan.configuration.scanType,
                depth: scan.configuration.depth,
                timeout: scan.configuration.timeout,
                timeoutMinutes: Math.round(scan.configuration.timeout / 60000),
                enableExploitValidation: scan.configuration.enableExploitValidation,
                aggressiveScanning: scan.configuration.aggressiveScanning
            },
            results: {
                vulnerabilitiesFound: scan.results.vulnerabilitiesFound,
                criticalVulnerabilities: scan.results.criticalVulnerabilities,
                highVulnerabilities: scan.results.highVulnerabilities,
                mediumVulnerabilities: scan.results.mediumVulnerabilities,
                lowVulnerabilities: scan.results.lowVulnerabilities,
                exploitsValidated: scan.results.exploitsValidated,
                falsePositives: scan.results.falsePositives,
                successRate: scan.results.vulnerabilitiesFound > 0 ? 
                    Math.round((1 - scan.results.falsePositives / scan.results.vulnerabilitiesFound) * 100) : 100
            },
            vulnerabilities: vulnerabilityDetails,
            metadata: {
                initiatedBy: scan.metadata.initiatedBy,
                scanReason: scan.metadata.scanReason,
                estimatedDuration: scan.metadata.estimatedDuration,
                estimatedDurationMinutes: Math.round(scan.metadata.estimatedDuration / 60000),
                scanningEngine: scan.metadata.scanningEngine
            },
            riskAssessment: {
                overallRisk: this.calculateScanRisk(vulnerabilityDetails),
                criticalRiskFactors: vulnerabilityDetails
                    .filter(v => v.severity === 'critical' && v.exploitable)
                    .map(v => v.name),
                remediationPriority: this.getRemediationPriority(vulnerabilityDetails)
            }
        };

        res.json({
            success: true,
            scan: detailedScan
        });

    } catch (error) {
        console.error('❌ Error getting scan details:', error.message);
        res.status(500).json({
            success: false,
            error: 'scan_details_service_error',
            message: 'Failed to get scan details'
        });
    }
});

/**
 * POST /api/vulnerability-assessment/penetration-tests
 * Start a new penetration test
 */
router.post('/penetration-tests', async (req, res) => {
    try {
        if (!vulnerabilityService) {
            return res.status(500).json({
                success: false,
                error: 'Vulnerability assessment service not initialized'
            });
        }

        const { targetId, testType, scope, methodology, enableSocialEngineering, enablePhysicalSecurity, maxExploitDepth, testDuration, safetyMode } = req.body;
        
        if (!targetId) {
            return res.status(400).json({
                success: false,
                error: 'targetId is required'
            });
        }

        const options = {
            testType: testType || 'black_box',
            scope: scope || 'limited',
            methodology: methodology || 'owasp_testing_guide',
            enableSocialEngineering: enableSocialEngineering === true,
            enablePhysicalSecurity: enablePhysicalSecurity === true,
            maxExploitDepth: maxExploitDepth || 3,
            testDuration: testDuration || 8 * 3600000, // 8 hours
            safetyMode: safetyMode !== false,
            tester: req.user?.id || req.headers['x-user-id'] || 'api_user'
        };

        console.log(`🔍 Starting penetration test for target: ${targetId}`);
        
        const testResult = await vulnerabilityService.executePenetrationTest(targetId, options);
        
        if (testResult.success) {
            res.status(201).json({
                success: true,
                message: 'Penetration test started successfully',
                test: {
                    id: testResult.testId,
                    targetName: testResult.targetName,
                    testType: testResult.testType,
                    methodology: testResult.methodology,
                    estimatedDuration: testResult.estimatedDuration,
                    estimatedDurationHours: testResult.estimatedDurationHours,
                    status: testResult.status
                },
                monitoring: {
                    progressEndpoint: testResult.progressEndpoint,
                    resultsEndpoint: `/api/vulnerability-assessment/penetration-tests/${testResult.testId}/results`,
                    stopEndpoint: `/api/vulnerability-assessment/penetration-tests/${testResult.testId}/stop`
                },
                testConfiguration: {
                    testType: options.testType,
                    scope: options.scope,
                    methodology: options.methodology,
                    socialEngineeringEnabled: options.enableSocialEngineering,
                    physicalSecurityEnabled: options.enablePhysicalSecurity,
                    maxExploitDepth: options.maxExploitDepth,
                    safetyModeEnabled: options.safetyMode
                },
                riskWarnings: this.getPentestRiskWarnings(options),
                timestamp: new Date().toISOString()
            });
        } else {
            res.status(400).json({
                success: false,
                error: testResult.error,
                message: testResult.message
            });
        }

    } catch (error) {
        console.error('❌ Error starting penetration test:', error.message);
        res.status(500).json({
            success: false,
            error: 'penetration_test_service_error',
            message: 'Penetration test service error'
        });
    }
});

/**
 * GET /api/vulnerability-assessment/vulnerabilities
 * Get vulnerabilities with filtering and pagination
 */
router.get('/vulnerabilities', (req, res) => {
    try {
        if (!vulnerabilityService) {
            return res.status(500).json({
                success: false,
                error: 'Vulnerability assessment service not initialized'
            });
        }

        const { severity, status, category, targetId, exploitable, limit = 50, page = 1 } = req.query;
        let vulnerabilities = Array.from(vulnerabilityService.vulnerabilities.values());

        // Apply filters
        if (severity) {
            vulnerabilities = vulnerabilities.filter(v => v.severity === severity);
        }
        if (status) {
            vulnerabilities = vulnerabilities.filter(v => v.status === status);
        }
        if (category) {
            vulnerabilities = vulnerabilities.filter(v => v.category === category);
        }
        if (targetId) {
            vulnerabilities = vulnerabilities.filter(v => v.targetId === targetId);
        }
        if (exploitable !== undefined) {
            vulnerabilities = vulnerabilities.filter(v => v.exploitable === (exploitable === 'true'));
        }

        // Sort by discovery date (newest first)
        vulnerabilities = vulnerabilities.sort((a, b) => b.discoveredAt - a.discoveredAt);

        // Pagination
        const totalVulnerabilities = vulnerabilities.length;
        const startIndex = (parseInt(page) - 1) * parseInt(limit);
        const endIndex = startIndex + parseInt(limit);
        const paginatedVulnerabilities = vulnerabilities.slice(startIndex, endIndex);

        const formattedVulnerabilities = paginatedVulnerabilities.map(vulnerability => {
            const target = vulnerabilityService.scanTargets.get(vulnerability.targetId);
            
            return {
                id: vulnerability.id,
                name: vulnerability.name,
                description: vulnerability.description.substring(0, 200) + (vulnerability.description.length > 200 ? '...' : ''),
                severity: vulnerability.severity,
                cvssScore: vulnerability.cvssScore,
                category: vulnerability.category,
                status: vulnerability.status,
                targetId: vulnerability.targetId,
                targetName: target?.name || 'Unknown Target',
                exploitable: vulnerability.exploitable,
                falsePositive: vulnerability.falsePositive,
                discoveredAt: new Date(vulnerability.discoveredAt).toISOString(),
                lastSeen: new Date(vulnerability.lastSeen).toISOString(),
                age: Date.now() - vulnerability.discoveredAt,
                ageDays: Math.round((Date.now() - vulnerability.discoveredAt) / (24 * 3600000)),
                remediation: {
                    type: vulnerability.remediation.type,
                    effort: vulnerability.remediation.effort
                },
                impact: vulnerability.impact,
                references: vulnerability.references.slice(0, 3), // First 3 references
                riskScore: this.calculateVulnerabilityRisk(vulnerability),
                remediationUrgency: this.getRemediationUrgency(vulnerability)
            };
        });

        res.json({
            success: true,
            vulnerabilities: formattedVulnerabilities,
            pagination: {
                page: parseInt(page),
                limit: parseInt(limit),
                total: totalVulnerabilities,
                totalPages: Math.ceil(totalVulnerabilities / parseInt(limit)),
                hasNext: endIndex < totalVulnerabilities,
                hasPrev: startIndex > 0
            },
            summary: {
                total: formattedVulnerabilities.length,
                bySeverity: vulnerabilities.reduce((acc, v) => {
                    acc[v.severity] = (acc[v.severity] || 0) + 1;
                    return acc;
                }, {}),
                byStatus: vulnerabilities.reduce((acc, v) => {
                    acc[v.status] = (acc[v.status] || 0) + 1;
                    return acc;
                }, {}),
                byCategory: vulnerabilities.reduce((acc, v) => {
                    acc[v.category] = (acc[v.category] || 0) + 1;
                    return acc;
                }, {}),
                exploitable: vulnerabilities.filter(v => v.exploitable).length,
                falsePositives: vulnerabilities.filter(v => v.falsePositive).length,
                avgCVSSScore: vulnerabilities.length > 0 ? 
                    Math.round(vulnerabilities.reduce((sum, v) => sum + v.cvssScore, 0) / vulnerabilities.length * 10) / 10 : 0,
                avgAge: vulnerabilities.length > 0 ? 
                    Math.round(vulnerabilities.reduce((sum, v) => sum + (Date.now() - v.discoveredAt), 0) / vulnerabilities.length / (24 * 3600000)) : 0
            }
        });

    } catch (error) {
        console.error('❌ Error getting vulnerabilities:', error.message);
        res.status(500).json({
            success: false,
            error: 'vulnerabilities_retrieval_service_error',
            message: 'Failed to retrieve vulnerabilities'
        });
    }
});

/**
 * POST /api/vulnerability-assessment/vulnerabilities/:vulnerabilityId/remediation
 * Create remediation task for a vulnerability
 */
router.post('/vulnerabilities/:vulnerabilityId/remediation', async (req, res) => {
    try {
        if (!vulnerabilityService) {
            return res.status(500).json({
                success: false,
                error: 'Vulnerability assessment service not initialized'
            });
        }

        const { vulnerabilityId } = req.params;
        const { assignedTo, dueDate, estimatedEffort } = req.body;

        const options = {
            assignedTo,
            dueDate: dueDate ? new Date(dueDate).getTime() - Date.now() : undefined,
            estimatedEffort
        };

        console.log(`🔍 Creating remediation task for vulnerability: ${vulnerabilityId}`);
        
        const remediationResult = await vulnerabilityService.createRemediationTask(vulnerabilityId, options);
        
        if (remediationResult.success) {
            res.status(201).json({
                success: true,
                message: 'Remediation task created successfully',
                task: {
                    id: remediationResult.taskId,
                    vulnerabilityName: remediationResult.vulnerabilityName,
                    priority: remediationResult.priority,
                    dueDate: remediationResult.dueDate,
                    estimatedEffort: remediationResult.estimatedEffort,
                    remediationType: remediationResult.remediationType,
                    approvalRequired: remediationResult.approvalRequired,
                    rollbackPlanRequired: remediationResult.rollbackPlanRequired
                },
                workflow: {
                    taskEndpoint: `/api/vulnerability-assessment/remediation-tasks/${remediationResult.taskId}`,
                    progressEndpoint: `/api/vulnerability-assessment/remediation-tasks/${remediationResult.taskId}/progress`,
                    approvalEndpoint: remediationResult.approvalRequired ? 
                        `/api/vulnerability-assessment/remediation-tasks/${remediationResult.taskId}/approve` : null
                },
                guidelines: {
                    testingRequired: true,
                    backupRecommended: remediationResult.priority === 'critical',
                    rollbackPlanRequired: remediationResult.rollbackPlanRequired,
                    verificationRequired: true
                },
                timestamp: new Date().toISOString()
            });
        } else {
            res.status(400).json({
                success: false,
                error: remediationResult.error,
                message: remediationResult.message
            });
        }

    } catch (error) {
        console.error('❌ Error creating remediation task:', error.message);
        res.status(500).json({
            success: false,
            error: 'remediation_task_service_error',
            message: 'Remediation task service error'
        });
    }
});

/**
 * GET /api/vulnerability-assessment/reports
 * Get vulnerability assessment reports
 */
router.get('/reports', (req, res) => {
    try {
        if (!vulnerabilityService) {
            return res.status(500).json({
                success: false,
                error: 'Vulnerability assessment service not initialized'
            });
        }

        const { format, audience, limit = 20 } = req.query;
        let reports = Array.from(vulnerabilityService.reports.values());

        // Apply filters
        if (format) {
            reports = reports.filter(r => r.metadata.reportFormat === format);
        }
        if (audience) {
            reports = reports.filter(r => r.metadata.audience === audience);
        }

        // Sort by generation date (newest first) and limit results
        reports = reports
            .sort((a, b) => b.generatedAt - a.generatedAt)
            .slice(0, parseInt(limit));

        const formattedReports = reports.map(report => ({
            id: report.id,
            title: report.title,
            generatedAt: new Date(report.generatedAt).toISOString(),
            generatedBy: report.generatedBy,
            reportPeriod: {
                startDate: report.reportPeriod.startDate,
                endDate: report.reportPeriod.endDate,
                durationDays: Math.round(report.reportPeriod.duration / (24 * 3600000))
            },
            executiveSummary: {
                totalScans: report.executiveSummary.totalScans,
                totalVulnerabilities: report.executiveSummary.totalVulnerabilities,
                criticalVulnerabilities: report.executiveSummary.criticalVulnerabilities,
                highVulnerabilities: report.executiveSummary.highVulnerabilities,
                remediatedVulnerabilities: report.executiveSummary.remediatedVulnerabilities,
                overallRiskScore: report.executiveSummary.overallRiskScore,
                trendAnalysis: report.executiveSummary.trendAnalysis
            },
            metadata: {
                reportFormat: report.metadata.reportFormat,
                confidentialityLevel: report.metadata.confidentialityLevel,
                audience: report.metadata.audience,
                nextReportDue: report.metadata.nextReportDue
            },
            downloadUrl: `/api/vulnerability-assessment/reports/${report.id}/download`,
            previewUrl: `/api/vulnerability-assessment/reports/${report.id}/preview`
        }));

        res.json({
            success: true,
            reports: formattedReports,
            summary: {
                total: formattedReports.length,
                byFormat: reports.reduce((acc, r) => {
                    acc[r.metadata.reportFormat] = (acc[r.metadata.reportFormat] || 0) + 1;
                    return acc;
                }, {}),
                byAudience: reports.reduce((acc, r) => {
                    acc[r.metadata.audience] = (acc[r.metadata.audience] || 0) + 1;
                    return acc;
                }, {}),
                totalVulnerabilitiesAnalyzed: reports.reduce((sum, r) => sum + r.executiveSummary.totalVulnerabilities, 0),
                avgRiskScore: reports.length > 0 ? 
                    Math.round(reports.reduce((sum, r) => sum + r.executiveSummary.overallRiskScore, 0) / reports.length * 10) / 10 : 0
            }
        });

    } catch (error) {
        console.error('❌ Error getting reports:', error.message);
        res.status(500).json({
            success: false,
            error: 'reports_retrieval_service_error',
            message: 'Failed to retrieve vulnerability assessment reports'
        });
    }
});

/**
 * POST /api/vulnerability-assessment/reports
 * Generate a new vulnerability assessment report
 */
router.post('/reports', async (req, res) => {
    try {
        if (!vulnerabilityService) {
            return res.status(500).json({
                success: false,
                error: 'Vulnerability assessment service not initialized'
            });
        }

        const { title, timeRange, format, audience } = req.body;

        const options = {
            title: title || 'Vulnerability Assessment Report',
            timeRange: timeRange || 30 * 24 * 3600000, // 30 days
            format: format || 'json',
            audience: audience || 'security_team',
            generatedBy: req.user?.id || req.headers['x-user-id'] || 'api_user'
        };

        console.log(`🔍 Generating vulnerability assessment report`);
        
        const reportResult = await vulnerabilityService.generateAssessmentReport(options);
        
        if (reportResult.success) {
            res.status(201).json({
                success: true,
                message: 'Vulnerability assessment report generated successfully',
                report: {
                    id: reportResult.reportId,
                    generatedAt: reportResult.generatedAt,
                    vulnerabilitiesAnalyzed: reportResult.vulnerabilitiesAnalyzed,
                    overallRiskScore: reportResult.overallRiskScore,
                    criticalVulnerabilities: reportResult.criticalVulnerabilities
                },
                access: {
                    reportUrl: reportResult.reportUrl,
                    downloadUrl: reportResult.downloadUrl,
                    viewEndpoint: `/api/vulnerability-assessment/reports/${reportResult.reportId}`,
                    shareEndpoint: `/api/vulnerability-assessment/reports/${reportResult.reportId}/share`
                },
                insights: {
                    riskLevel: this.getRiskLevel(reportResult.overallRiskScore),
                    actionRequired: reportResult.criticalVulnerabilities > 0,
                    executiveBriefingRecommended: reportResult.overallRiskScore >= 7.0,
                    nextReportRecommended: '7 days'
                },
                timestamp: new Date().toISOString()
            });
        } else {
            res.status(400).json({
                success: false,
                error: reportResult.error,
                message: reportResult.message
            });
        }

    } catch (error) {
        console.error('❌ Error generating report:', error.message);
        res.status(500).json({
            success: false,
            error: 'report_generation_service_error',
            message: 'Report generation service error'
        });
    }
});

/**
 * GET /api/vulnerability-assessment/targets
 * Get scan targets and their configurations
 */
router.get('/targets', (req, res) => {
    try {
        if (!vulnerabilityService) {
            return res.status(500).json({
                success: false,
                error: 'Vulnerability assessment service not initialized'
            });
        }

        const { type, priority, active = 'true' } = req.query;
        let targets = Array.from(vulnerabilityService.scanTargets.values());

        // Apply filters
        if (active !== 'all') {
            targets = targets.filter(t => t.active === (active === 'true'));
        }
        if (type) {
            targets = targets.filter(t => t.type === type);
        }
        if (priority) {
            targets = targets.filter(t => t.priority === priority);
        }

        const formattedTargets = targets.map(target => ({
            id: target.id,
            name: target.name,
            type: target.type,
            priority: target.priority,
            active: target.active,
            url: target.url,
            endpoints: target.endpoints || [],
            targets: target.targets || [],
            scanTypes: target.scanTypes,
            scanFrequency: target.scanFrequency,
            scanFrequencyDays: Math.round(target.scanFrequency / (24 * 3600000)),
            lastScan: target.lastScan ? new Date(target.lastScan).toISOString() : null,
            scanCount: target.scanCount,
            vulnerabilitiesFound: target.vulnerabilitiesFound,
            nextScanDue: target.lastScan ? 
                new Date(target.lastScan + target.scanFrequency).toISOString() : 
                new Date().toISOString(),
            scanStatus: this.getTargetScanStatus(target),
            riskLevel: this.getTargetRiskLevel(target.vulnerabilitiesFound, target.scanCount),
            createdAt: new Date(target.createdAt).toISOString()
        }));

        res.json({
            success: true,
            targets: formattedTargets,
            summary: {
                total: formattedTargets.length,
                active: formattedTargets.filter(t => t.active).length,
                byType: targets.reduce((acc, t) => {
                    acc[t.type] = (acc[t.type] || 0) + 1;
                    return acc;
                }, {}),
                byPriority: targets.reduce((acc, t) => {
                    acc[t.priority] = (acc[t.priority] || 0) + 1;
                    return acc;
                }, {}),
                totalScansPerformed: targets.reduce((sum, t) => sum + t.scanCount, 0),
                totalVulnerabilitiesFound: targets.reduce((sum, t) => sum + t.vulnerabilitiesFound, 0),
                avgVulnerabilitiesPerTarget: targets.length > 0 ? 
                    Math.round(targets.reduce((sum, t) => sum + t.vulnerabilitiesFound, 0) / targets.length) : 0,
                targetsDueSoon: formattedTargets.filter(t => 
                    new Date(t.nextScanDue).getTime() - Date.now() < 24 * 3600000
                ).length
            }
        });

    } catch (error) {
        console.error('❌ Error getting scan targets:', error.message);
        res.status(500).json({
            success: false,
            error: 'targets_retrieval_service_error',
            message: 'Failed to retrieve scan targets'
        });
    }
});

/**
 * GET /api/vulnerability-assessment/status
 * Get vulnerability assessment service status and metrics
 */
router.get('/status', (req, res) => {
    try {
        if (!vulnerabilityService) {
            return res.status(500).json({
                success: false,
                error: 'Vulnerability assessment service not initialized'
            });
        }

        const status = vulnerabilityService.getVulnerabilityAssessmentStatus();
        
        res.json({
            success: true,
            status: {
                service: {
                    active: status.isActive,
                    lastActivity: new Date(status.lastActivity).toISOString()
                },
                scanning: {
                    automatedScanningEnabled: status.configuration.scanning.enableAutomatedScanning,
                    continuousScanningEnabled: status.configuration.scanning.enableContinuousScanning,
                    scanInterval: status.configuration.scanning.scanInterval,
                    scanIntervalDays: Math.round(status.configuration.scanning.scanInterval / (24 * 3600000)),
                    maxConcurrentScans: status.configuration.scanning.maxConcurrentScans,
                    scanTimeoutMinutes: Math.round(status.configuration.scanning.scanTimeout / 60000),
                    deepScanningEnabled: status.configuration.scanning.enableDeepScanning,
                    complianceScanningEnabled: status.configuration.scanning.enableComplianceScanning
                },
                assessment: {
                    penetrationTestingEnabled: status.configuration.assessment.enablePenetrationTesting,
                    testingFrequencyDays: Math.round(status.configuration.assessment.testingFrequency / (24 * 3600000)),
                    testingDepth: status.configuration.assessment.testingDepth,
                    redTeamExercisesEnabled: status.configuration.assessment.enableRedTeamExercises,
                    socialEngineeringEnabled: status.configuration.assessment.enableSocialEngineering,
                    physicalSecurityEnabled: status.configuration.assessment.enablePhysicalSecurity
                },
                vulnerability: {
                    severityThresholds: status.configuration.vulnerability.severityThresholds,
                    autoRemediationEnabled: status.configuration.vulnerability.autoRemediation,
                    remediationTimeoutDays: Math.round(status.configuration.vulnerability.remediationTimeout / (24 * 3600000)),
                    falsePositiveFilteringEnabled: status.configuration.vulnerability.falsePositiveFiltering,
                    contextualScoringEnabled: status.configuration.vulnerability.contextualScoring
                },
                reporting: {
                    automatedReportingEnabled: status.configuration.reporting.enableAutomatedReporting,
                    reportFormats: status.configuration.reporting.reportFormats,
                    executiveReportingEnabled: status.configuration.reporting.executiveReporting,
                    complianceReportingEnabled: status.configuration.reporting.complianceReporting,
                    trendAnalysisEnabled: status.configuration.reporting.trendAnalysis,
                    benchmarkingEnabled: status.configuration.reporting.benchmarking
                },
                integration: {
                    cveIntegrationEnabled: status.configuration.integration.enableCVEIntegration,
                    nvdIntegrationEnabled: status.configuration.integration.enableNVDIntegration,
                    owaspIntegrationEnabled: status.configuration.integration.enableOWASPIntegration,
                    threatIntelligenceIntegrationEnabled: status.configuration.integration.threatIntelligenceIntegration,
                    ticketSystemIntegrationEnabled: status.configuration.integration.ticketSystemIntegration
                },
                remediation: {
                    automatedRemediationEnabled: status.configuration.remediation.enableAutomatedRemediation,
                    autoApplyPatchesEnabled: status.configuration.remediation.autoApplyPatches,
                    testPatchesFirstEnabled: status.configuration.remediation.testPatchesFirst,
                    rollbackCapabilityEnabled: status.configuration.remediation.rollbackCapability,
                    changeManagementIntegrationEnabled: status.configuration.remediation.changeManagementIntegration
                },
                metrics: status.metrics
            },
            timestamp: new Date().toISOString()
        });

    } catch (error) {
        console.error('❌ Error getting vulnerability assessment status:', error.message);
        res.status(500).json({
            success: false,
            error: 'status_service_error',
            message: 'Failed to get vulnerability assessment status'
        });
    }
});

// Helper methods
router.calculateScanRisk = function(vulnerabilities) {
    if (vulnerabilities.length === 0) return 'low';
    
    const critical = vulnerabilities.filter(v => v.severity === 'critical').length;
    const high = vulnerabilities.filter(v => v.severity === 'high').length;
    const exploitable = vulnerabilities.filter(v => v.exploitable).length;
    
    if (critical > 0 || exploitable > 2) return 'critical';
    if (high > 2 || exploitable > 0) return 'high';
    if (vulnerabilities.length > 5) return 'medium';
    return 'low';
};

router.getRemediationPriority = function(vulnerabilities) {
    return vulnerabilities
        .filter(v => v.severity === 'critical' || (v.severity === 'high' && v.exploitable))
        .sort((a, b) => b.cvssScore - a.cvssScore)
        .slice(0, 5)
        .map(v => ({
            name: v.name,
            severity: v.severity,
            cvssScore: v.cvssScore,
            exploitable: v.exploitable
        }));
};

router.getPentestRiskWarnings = function(options) {
    const warnings = [];
    
    if (!options.safetyMode) {
        warnings.push('Safety mode disabled - proceed with caution');
    }
    
    if (options.enableSocialEngineering) {
        warnings.push('Social engineering tests enabled - staff notification recommended');
    }
    
    if (options.enablePhysicalSecurity) {
        warnings.push('Physical security tests enabled - coordinate with facilities');
    }
    
    if (options.maxExploitDepth > 2) {
        warnings.push('Deep exploitation enabled - monitor for system impact');
    }
    
    return warnings;
};

router.calculateVulnerabilityRisk = function(vulnerability) {
    let risk = vulnerability.cvssScore;
    
    if (vulnerability.exploitable) risk += 2;
    if (vulnerability.severity === 'critical') risk += 1;
    if (vulnerability.category === 'injection') risk += 1;
    
    return Math.min(10, Math.round(risk * 10) / 10);
};

router.getRemediationUrgency = function(vulnerability) {
    const age = Date.now() - vulnerability.discoveredAt;
    const ageDays = Math.round(age / (24 * 3600000));
    
    if (vulnerability.severity === 'critical' && ageDays > 3) return 'overdue';
    if (vulnerability.severity === 'high' && ageDays > 14) return 'overdue';
    if (vulnerability.severity === 'critical') return 'urgent';
    if (vulnerability.severity === 'high' && vulnerability.exploitable) return 'urgent';
    if (vulnerability.severity === 'high') return 'high';
    if (vulnerability.severity === 'medium') return 'medium';
    return 'low';
};

router.getRiskLevel = function(riskScore) {
    if (riskScore >= 9.0) return 'critical';
    if (riskScore >= 7.0) return 'high';
    if (riskScore >= 4.0) return 'medium';
    return 'low';
};

router.getTargetScanStatus = function(target) {
    if (!target.lastScan) return 'never_scanned';
    
    const timeSinceLastScan = Date.now() - target.lastScan;
    
    if (timeSinceLastScan > target.scanFrequency * 1.2) return 'overdue';
    if (timeSinceLastScan > target.scanFrequency) return 'due';
    return 'current';
};

router.getTargetRiskLevel = function(vulnerabilitiesFound, scanCount) {
    if (scanCount === 0) return 'unknown';
    
    const avgVulnerabilities = vulnerabilitiesFound / scanCount;
    
    if (avgVulnerabilities > 10) return 'high';
    if (avgVulnerabilities > 5) return 'medium';
    return 'low';
};

module.exports = router;